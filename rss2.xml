<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mark&#39;s blogs</title>
    <link>http://marksblog.cn/</link>
    
    <atom:link href="http://marksblog.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>心之所向，行之可往</description>
    <pubDate>Sat, 03 Jun 2023 11:33:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode-198-打家劫舍</title>
      <link>http://marksblog.cn/posts/9b6273f5/</link>
      <guid>http://marksblog.cn/posts/9b6273f5/</guid>
      <pubDate>Sat, 03 Jun 2023 11:33:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[nums.size()+1]&lt;/code&gt; 表示在 &lt;code&gt;nums.size()&lt;/code&gt; 个物品中进行选取能够得到的最大的物品价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在 &lt;code&gt;j&lt;/code&gt; 个物品中选取，可以选取第 &lt;code&gt;j&lt;/code&gt; 个物品也可以不进行选取，那么 &lt;code&gt;dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 不存在可选元素， &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于 &lt;code&gt;dp[1]&lt;/code&gt; 只能选取第一个元素 &lt;code&gt;dp[1]=nums[0]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=[1,2,3,1]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp={0,1,0,0,0}&lt;br&gt;dp={0,1,2,0,0}&lt;br&gt;dp={0,1,2,4,0}&lt;br&gt;dp={0,1,2,4,4}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode 198 打家劫舍"></a>LeetCode 198 打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><blockquote><p>  输入：[1,2,3,1]<br>    输出：4<br>    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>        偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[nums.size()+1]</code> 表示在 <code>nums.size()</code> 个物品中进行选取能够得到的最大的物品价值。</p></li><li><p>动态规划数组的推导：在 <code>j</code> 个物品中选取，可以选取第 <code>j</code> 个物品也可以不进行选取，那么 <code>dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])</code></p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 不存在可选元素， <code>dp[0]=0</code> ，对于 <code>dp[1]</code> 只能选取第一个元素 <code>dp[1]=nums[0]</code> </p></li><li><p>动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。</p></li><li><p>举例验证：对于 <code>nums=[1,2,3,1]</code> </p></li></ol><blockquote><p>dp={0,1,0,0,0}<br>dp={0,1,2,0,0}<br>dp={0,1,2,4,0}<br>dp={0,1,2,4,4}</p></blockquote><p>验证正确。</p><p>此处在进行计算时，实际上只使用到了前两个元素的值，那么只需要常数的元素空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(n1,n0+nums[i<span class="number">-1</span>]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/9b6273f5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>完全背包问题总结</title>
      <link>http://marksblog.cn/posts/97265db6/</link>
      <guid>http://marksblog.cn/posts/97265db6/</guid>
      <pubDate>Fri, 02 Jun 2023 12:30:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;完全背包问题总结&quot;&gt;&lt;a href=&quot;#完全背包问题总结&quot; class=&quot;headerlink&quot; title=&quot;完全背包问题总结&quot;&gt;&lt;/a&gt;完全背包问题总结&lt;/h1&gt;&lt;p&gt;首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 &lt;code&gt;W&lt;/code&gt; 的背包。第 &lt;code&gt;i&lt;/code&gt; 件物品的重量是 &lt;code&gt;weight[i]&lt;/code&gt; ，得到的价值是 &lt;code&gt;value[i]&lt;/code&gt; 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。&lt;/p&gt;
&lt;p&gt;相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 &lt;code&gt;n&lt;/code&gt; 个物品可供选择（即从所有的物品中做任意的选择）。&lt;/p&gt;
&lt;p&gt;完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 &lt;code&gt;i&lt;/code&gt; 次迭代时，0/1背包只能使用一次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="完全背包问题总结"><a href="#完全背包问题总结" class="headerlink" title="完全背包问题总结"></a>完全背包问题总结</h1><p>首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 <code>W</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p><p>相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 <code>n</code> 个物品可供选择（即从所有的物品中做任意的选择）。</p><p>完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。</p><ol><li><p>对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 <code>i</code> 次迭代时，0/1背包只能使用一次物品 <code>weight[i]</code> ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 <code>weight[i]</code> ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）</p></li><li><p>先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。</p></li></ol><h2 id="LeetCode-377-组合总和Ⅳ"><a href="#LeetCode-377-组合总和Ⅳ" class="headerlink" title="LeetCode 377 组合总和Ⅳ"></a>LeetCode 377 组合总和Ⅳ</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和 Ⅳ</a></p><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>本题求解的并不是组合问题，是一个排序问题，在题目示例中将 <code>1,2,1</code> 和 <code>1,1,2</code> 视为两种不同的组合，也就是对于元素的选取顺序是敏感的。那么应该先遍历背包再遍历物品，并且此处求解的是恰好装满的情形，相应的递推公式为 <code>dp[j]+=dp[j-nums[i]]</code></p><h2 id="LeetCode-518-零钱兑换II"><a href="#LeetCode-518-零钱兑换II" class="headerlink" title="LeetCode 518 零钱兑换II"></a>LeetCode 518 零钱兑换II</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>根据题中的示例，本题求解的是一个组合问题。</p><p>并且此处的背包问题是一个恰好装满的情形，那么对于组合问题基本思路就是先遍历物品再遍历背包，那么递推公式为： <code>dp[j]+=dp[j-coins[i]]</code> ，在进行初始化是一定要将 <code>dp[0]=1</code> </p><h2 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode 322 零钱兑换"></a>LeetCode 322 零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>此处的最优化问题为：求解能够恰好装满背包的最少硬币数量，那么对于组合和排列都是相同的，两种遍历顺序都是可以的。基本的递推公式为：<code>dp[j]=min(dp[j],dp[j-coins[i]]+1)</code> ，要让上述递推公式成立，需要在数组的初始化时进行特殊处理，对于 <code>dp[0]</code> 只需要0个硬币即可装满。那么对于其他的值明显都装不满，因此初始为 <code>INT_MAX</code> ，并且每次判断 <code>dp[j-coins[i]]!=INT_MAX</code></p><h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>此处和上述问题是非常类似的，也是在求解将背包恰好装满的最少的元素数量。但是此处的元素要求是完全平方数，因此在遍历物品的同时去生成相应的完全平方数即可。对于 <code>dp[0]</code> 依旧是初始化为0。其他元素全部初始化为 <code>INT_MAX</code> 。对应的递推公式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 要求 <code>dp[j-nums[i]]!=INT_MAX</code></p><h2 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>此处需要注意的是：本题是一个排列问题，一定要先遍历背包，再遍历物品，也就是对于任意的背包大小都要能够使用全部的物品去进行填充，否则对于 <code>applepenapple</code> 这样的情形，在仅使用 <code>apple</code> 时，不能将后续的也标记为装满。那么在使用 <code>pen</code> 去填充时，无法使用 <code>apple</code> 将后续填满。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/97265db6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-139-单词拆分</title>
      <link>http://marksblog.cn/posts/4a1c4ee7/</link>
      <guid>http://marksblog.cn/posts/4a1c4ee7/</guid>
      <pubDate>Thu, 01 Jun 2023 00:58:59 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。&lt;/p&gt;
&lt;p&gt;此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）&lt;/p&gt;
&lt;p&gt;考虑这样一种情况： &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 那么先遍历物品，再遍历背包，初始时只能使用 &lt;code&gt;apple&lt;/code&gt; 那么只能将第一个 &lt;code&gt;apple&lt;/code&gt; 恰好装满，在第二次迭代中，是只考虑增加 &lt;code&gt;pen&lt;/code&gt; 的情形，但实际上还需要使用 &lt;code&gt;apple&lt;/code&gt; 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[s.size()+1]&lt;/code&gt; 表示长度为 &lt;code&gt;s.size()&lt;/code&gt; 的字符串能否恰好装满&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;j&lt;/code&gt; 次迭代中，判断字符从 &lt;code&gt;0-j-1&lt;/code&gt; 位置的字符串 &lt;code&gt;s&lt;/code&gt; 能否恰好装满，对于每一个物品 &lt;code&gt;wordDict[i]&lt;/code&gt; 都需要尝试从 &lt;code&gt;j-1&lt;/code&gt; 处向前装入试试，所以有：其中 &lt;code&gt;match&lt;/code&gt; 是字符串匹配操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(j&amp;gt;=wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dp[j]=dp[j]||(dp[j-wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()]&amp;amp;&amp;amp;&lt;span class=&quot;built_in&quot;&gt;match&lt;/span&gt;(s,j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,wordDict[i]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于&lt;code&gt;dp[0]&lt;/code&gt; 一定是能够恰好装满的，所以 &lt;code&gt;dp[0]=true&lt;/code&gt; 其他全部初始化为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 动态规划数组的推导过程为：验证成立&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,1,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h1><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例：</p><blockquote><p>  输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>    输出: true<br>    解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p></blockquote><ul><li>1 &lt;= <code>s.length</code> &lt;= 300</li><li>1 &lt;= <code>wordDict.length</code> &lt;= 1000</li><li>1 &lt;= <code>wordDict[i].length</code> &lt;= 20</li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 互不相同</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。</p><p>此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）</p><p>考虑这样一种情况： <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 那么先遍历物品，再遍历背包，初始时只能使用 <code>apple</code> 那么只能将第一个 <code>apple</code> 恰好装满，在第二次迭代中，是只考虑增加 <code>pen</code> 的情形，但实际上还需要使用 <code>apple</code> 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[s.size()+1]</code> 表示长度为 <code>s.size()</code> 的字符串能否恰好装满</p></li><li><p>动态规划数组的推导：在第 <code>j</code> 次迭代中，判断字符从 <code>0-j-1</code> 位置的字符串 <code>s</code> 能否恰好装满，对于每一个物品 <code>wordDict[i]</code> 都需要尝试从 <code>j-1</code> 处向前装入试试，所以有：其中 <code>match</code> 是字符串匹配操作。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：对于<code>dp[0]</code> 一定是能够恰好装满的，所以 <code>dp[0]=true</code> 其他全部初始化为 <code>false</code></p></li><li><p>动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式</p></li><li><p>举例验证：对于 <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 动态规划数组的推导过程为：验证成立</p></li></ol><blockquote><p>  1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,1,</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string&amp; s,<span class="type">int</span> j,string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i]!=s[j-word.<span class="built_in">size</span>()+<span class="number">1</span>+i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordDict.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/4a1c4ee7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-279-完全平方数</title>
      <link>http://marksblog.cn/posts/null/</link>
      <guid>http://marksblog.cn/posts/null/</guid>
      <pubDate>Tue, 30 May 2023 12:20:19 GMT</pubDate>
      
      <description>&lt;p&gt;将问题转化为完全背包问题，那么此处背包的容量就是 &lt;code&gt;n&lt;/code&gt; ，并没有给定相应的物品，但是要将背包 &lt;code&gt;n&lt;/code&gt; 装满，那么使用的物品就应该是 &lt;code&gt;1-n&lt;/code&gt; 中的全部完全平方数，首先创建物品数组。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; nums;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i*i&amp;lt;=n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nums.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(i*i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么此处的物品数组就是 &lt;code&gt;nums&lt;/code&gt; ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和&lt;a href=&quot;https://leetcode.cn/problems/coin-change/&quot;&gt;322.零钱兑换&lt;/a&gt;完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示总和为 &lt;code&gt;n&lt;/code&gt; 的最少的完全平方数的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，考虑元素 &lt;code&gt;nums[i]&lt;/code&gt; ，尝试使用 &lt;code&gt;nums[i]&lt;/code&gt; 来减少数量 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; （此处需要判断 &lt;code&gt;dp[j-nums[i]]!=INT_MAX&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于其他元素，由于递推方式为 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; 那么对于初始不能恰好装满的容量，都初始化为 &lt;code&gt;INT_MAX&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：&lt;code&gt;n=13&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h1><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例：</p><blockquote><p>  输入：n = 13<br>    输出：2<br>    解释：13 = 4 + 9</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题，那么此处背包的容量就是 <code>n</code> ，并没有给定相应的物品，但是要将背包 <code>n</code> 装满，那么使用的物品就应该是 <code>1-n</code> 中的全部完全平方数，首先创建物品数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此处的物品数组就是 <code>nums</code> ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和<a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a>完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示总和为 <code>n</code> 的最少的完全平方数的数量</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，考虑元素 <code>nums[i]</code> ，尝试使用 <code>nums[i]</code> 来减少数量 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> （此处需要判断 <code>dp[j-nums[i]]!=INT_MAX</code>）</p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 <code>dp[0]=0</code> ，对于其他元素，由于递推方式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 那么对于初始不能恰好装满的容量，都初始化为 <code>INT_MAX</code> 。</p></li><li><p>动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。</p></li><li><p>举例验证：<code>n=13</code> </p></li></ol><blockquote><p>  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums[i];j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-nums[i]]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-nums[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处的空间复杂度可优化，对于物品数组是可以不存储的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-i*i]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</category>
      
      
      <comments>http://marksblog.cn/posts/null/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-322-零钱兑换</title>
      <link>http://marksblog.cn/posts/d74e0b6/</link>
      <guid>http://marksblog.cn/posts/d74e0b6/</guid>
      <pubDate>Tue, 30 May 2023 02:17:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;不同于&lt;a href=&quot;https://leetcode.cn/problems/coin-change-ii/&quot;&gt;518.零钱兑换II&lt;/a&gt;，此处需要求解的是，使用最少的硬币个数得到整数 &lt;code&gt;amount&lt;/code&gt; ，此处的硬币数量是无限的。此处是一个组合问题，不存在选取顺序的问题。将之转化为完全背包问题：背包的容量为 &lt;code&gt;amount&lt;/code&gt; ，物品的重量为 &lt;code&gt;coins&lt;/code&gt; ，每一个物品的价值都为1，此处求解的是物品的最小价值。但是，此处的不同点在与，在向背包中装入物品时，要求将背包恰好装满。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义动态规划数组 &lt;code&gt;dp[amount+1]&lt;/code&gt; 表示将 &lt;code&gt;amount&lt;/code&gt; 装满所需的最少硬币个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，在硬币 &lt;code&gt;0-i&lt;/code&gt; 中进行选择，那么主要是 &lt;code&gt;coins[i]&lt;/code&gt; 的选择问题。此处在进行递推时，需要考虑到可行的条件。首先是 &lt;code&gt;dp[j]&lt;/code&gt; 的值，若是 &lt;code&gt;dp[j]=-1&lt;/code&gt; 说明之前不存在方案将之装满，那么就需要查看 &lt;code&gt;dp[j-coins[i]]&lt;/code&gt; 的值是否为 &lt;code&gt;-1&lt;/code&gt; ，若是为说明当前依旧无法装满，不修改值，负责当前存在从 &lt;code&gt;dp[j-coins[i]]&lt;/code&gt; 的基础上将之装满的方案，对应需要的最少硬币数就是 &lt;code&gt;dp[j-coins[i]]+1&lt;/code&gt; ，若是 &lt;code&gt;dp[j]!=-1&lt;/code&gt; ，说明当前就存在可以装满的方案，那么尝试装入 &lt;code&gt;coins[i]&lt;/code&gt; 看能否更少，当然需要 &lt;code&gt;dp[j-coins[i]]!=-1&lt;/code&gt; ，那么总体的推导过程就是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j-coins[i]]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[j]=&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;(dp[j],dp[j-coins[i]]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j-coins[i]]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[j]=dp[j-coins[i]]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始时全部初始为 &lt;code&gt;-1&lt;/code&gt; 表示不存在装满的方案，而对于 &lt;code&gt;dp[0]&lt;/code&gt; 装满0的背包，只需要0个硬币，初始化为 &lt;code&gt;dp[0]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处先遍历物品，再遍历背包，并且在对背包遍历时从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证： &lt;code&gt;coins = [1, 2, 5], amount = 11&lt;/code&gt; 那么动态规划数组的推导过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;    dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11}&lt;br&gt;    dp={0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6}&lt;br&gt;    dp={0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3}&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode 322 零钱兑换"></a>LeetCode 322 零钱兑换</h1><p><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例：</p><blockquote><p>输入：coins = [1, 2, 5], amount = 11<br> 输出：3<br> 解释：11 = 5 + 5 + 1</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>不同于<a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a>，此处需要求解的是，使用最少的硬币个数得到整数 <code>amount</code> ，此处的硬币数量是无限的。此处是一个组合问题，不存在选取顺序的问题。将之转化为完全背包问题：背包的容量为 <code>amount</code> ，物品的重量为 <code>coins</code> ，每一个物品的价值都为1，此处求解的是物品的最小价值。但是，此处的不同点在与，在向背包中装入物品时，要求将背包恰好装满。</p><ol><li><p>动态规划数组的定义：定义动态规划数组 <code>dp[amount+1]</code> 表示将 <code>amount</code> 装满所需的最少硬币个数。</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，在硬币 <code>0-i</code> 中进行选择，那么主要是 <code>coins[i]</code> 的选择问题。此处在进行递推时，需要考虑到可行的条件。首先是 <code>dp[j]</code> 的值，若是 <code>dp[j]=-1</code> 说明之前不存在方案将之装满，那么就需要查看 <code>dp[j-coins[i]]</code> 的值是否为 <code>-1</code> ，若是为说明当前依旧无法装满，不修改值，负责当前存在从 <code>dp[j-coins[i]]</code> 的基础上将之装满的方案，对应需要的最少硬币数就是 <code>dp[j-coins[i]]+1</code> ，若是 <code>dp[j]!=-1</code> ，说明当前就存在可以装满的方案，那么尝试装入 <code>coins[i]</code> 看能否更少，当然需要 <code>dp[j-coins[i]]!=-1</code> ，那么总体的推导过程就是：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">        dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：在初始时全部初始为 <code>-1</code> 表示不存在装满的方案，而对于 <code>dp[0]</code> 装满0的背包，只需要0个硬币，初始化为 <code>dp[0]=0</code></p></li><li><p>动态规划数组的遍历顺序：此处先遍历物品，再遍历背包，并且在对背包遍历时从前向后遍历。</p></li><li><p>举例验证： <code>coins = [1, 2, 5], amount = 11</code> 那么动态规划数组的推导过程为：</p></li></ol><p>&gt;<br>    dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11}<br>    dp={0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6}<br>    dp={0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3}</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">                        dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">                        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/d74e0b6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>01背包问题总结</title>
      <link>http://marksblog.cn/posts/39479a98/</link>
      <guid>http://marksblog.cn/posts/39479a98/</guid>
      <pubDate>Sun, 28 May 2023 09:21:41 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;01背包问题总结&quot;&gt;&lt;a href=&quot;#01背包问题总结&quot; class=&quot;headerlink&quot; title=&quot;01背包问题总结&quot;&gt;&lt;/a&gt;01背包问题总结&lt;/h1&gt;&lt;p&gt;首先，需要清楚的是0/1背包问题本身：有 &lt;code&gt;n&lt;/code&gt; 件物品和一个最多能背重量为 &lt;code&gt;w&lt;/code&gt; 的背包。第 &lt;code&gt;i&lt;/code&gt; 件物品的重量是 &lt;code&gt;weight[i]&lt;/code&gt; ，得到的价值是 &lt;code&gt;value[i]&lt;/code&gt; 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。&lt;/p&gt;
&lt;p&gt;此处使用动态规划求解，问题的划分方式为：使用一个二维数组对问题进行两部分的划分。对于 &lt;code&gt;dp[i][j]&lt;/code&gt; 求解的是，当背包容量为 &lt;code&gt;j&lt;/code&gt; 时，在物品 &lt;code&gt;0-i&lt;/code&gt; 中选择能够获取到的最大的容量。&lt;/p&gt;
&lt;p&gt;那么在采取逐行遍历的方式，就是每一次增加物品的数量，递推公式为： &lt;code&gt;dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;采取逐列遍历的方式，每一次增加的是背包的容量，那么递推公式为： &lt;code&gt;dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用滚动数组实现动态规划的过程：基于背包容量的滚动数组实现，那么此处就一定要先遍历物品再遍历背包了，因为动态规划数组的含义是，在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，使用 &lt;code&gt;0-i&lt;/code&gt; 个物品去填充背包，能够得到的背包中物品的最大价值。并且是0/1背包问题，那么对于背包的遍历顺序一定要是&lt;/p&gt;
&lt;p&gt;能否基于物品数量的滚动数组实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n]&lt;/code&gt; ，在初始时表示，当背包容量为0时，能够装下的最大的物品价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：对于第 &lt;code&gt;j&lt;/code&gt; 次迭代时，表示当背包容量为 &lt;code&gt;j&lt;/code&gt; 时，能够装下的物品的最大价值。在一维的情形下，背包容量减去 &lt;code&gt;weight[i]&lt;/code&gt; 的情形无法实现递推。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此在0/1背包中使用滚动数组，只能基于背包容量的数组来实现。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="01背包问题总结"><a href="#01背包问题总结" class="headerlink" title="01背包问题总结"></a>01背包问题总结</h1><p>首先，需要清楚的是0/1背包问题本身：有 <code>n</code> 件物品和一个最多能背重量为 <code>w</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p>此处使用动态规划求解，问题的划分方式为：使用一个二维数组对问题进行两部分的划分。对于 <code>dp[i][j]</code> 求解的是，当背包容量为 <code>j</code> 时，在物品 <code>0-i</code> 中选择能够获取到的最大的容量。</p><p>那么在采取逐行遍历的方式，就是每一次增加物品的数量，递推公式为： <code>dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])</code></p><p>采取逐列遍历的方式，每一次增加的是背包的容量，那么递推公式为： <code>dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])</code></p><p>使用滚动数组实现动态规划的过程：基于背包容量的滚动数组实现，那么此处就一定要先遍历物品再遍历背包了，因为动态规划数组的含义是，在第 <code>i</code> 次迭代中，使用 <code>0-i</code> 个物品去填充背包，能够得到的背包中物品的最大价值。并且是0/1背包问题，那么对于背包的遍历顺序一定要是</p><p>能否基于物品数量的滚动数组实现：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n]</code> ，在初始时表示，当背包容量为0时，能够装下的最大的物品价值。</p></li><li><p>动态规划数组的推导：对于第 <code>j</code> 次迭代时，表示当背包容量为 <code>j</code> 时，能够装下的物品的最大价值。在一维的情形下，背包容量减去 <code>weight[i]</code> 的情形无法实现递推。</p></li></ol><p>因此在0/1背包中使用滚动数组，只能基于背包容量的数组来实现。</p><h2 id="LeetCode-416-分割等和子集"><a href="#LeetCode-416-分割等和子集" class="headerlink" title="LeetCode 416 分割等和子集"></a>LeetCode 416 分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416.分割等和子集</a></p><p>给你一个只包含正整数的非空数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>此处的重点是问题的转化，要求两个子集的元素和相等，将元素的和转化为背包的大小，也就是使用一个容量等于全部元素和一半的背包去装数组元素能否恰好将背包装满。这一半能够装满，那么另外一半也能够装满。也就完成了划分。</p><p>动态规划数组的定义为： <code>dp[j]</code> 表示：当背包容量为 <code>j</code> 时，能够恰好将背包装满，那么递推公式就为：在第 <code>i</code> 次迭代中在 <code>0-i</code> 个元素中进行选择，<code>dp[j]=dp[j]||dp[j-nums[i]]</code> 此处的背包也是需要从后向前遍历，为了防止重复选择。</p><p>本题的重点在于问题的转化，将等和子集划分，转化为一个0/1背包问题。</p><h2 id="LeetCode-1049-最后一块石头的重量II"><a href="#LeetCode-1049-最后一块石头的重量II" class="headerlink" title="LeetCode 1049 最后一块石头的重量II"></a>LeetCode 1049 最后一块石头的重量II</h2><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量II</a></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code> 。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code> ，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code> ，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code> 。</li></ul><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。</p><p>本题的求解方式也是需要对问题进行转化，两块石头粉碎后的重量一定是小重量石头的两倍，那问题就像是一个消消乐游戏。那么想要找到最优的方案，就是将石头划分为两个集合，这两个集合的石头总重量要尽可能的接近。</p><p>最接近的划分方式就是：两个集合的总重量恰好为全部石头总重量的一半，转为背包容量为sum/2，能否将背包恰好装满。定义动态规划数组 <code>dp[sum/2+1]</code> ，表示能否恰好将 <code>sum/2</code> 容量的背包装满，那么最后只要找到能够恰好装满的最大容量的背包即可。问题和分割等和子集类似。</p><h2 id="LeetCode-494-目标和"><a href="#LeetCode-494-目标和" class="headerlink" title="LeetCode 494 目标和"></a>LeetCode 494 目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">494.目标和</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>+</code> 或 <code>-</code> ，然后串联起所有整数，可以构造一个表达式：</p><p>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>+</code> ，在 <code>1</code> 之前添加 <code>-</code> ，然后串联起来得到表达式 <code>+2-1</code> 。<br>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同表达式的数目。</p><p>本题对于问题的转化是相对复杂的：首先，假设在表达式中为负号元素的总和为 <code>neg</code> ，所有元素的总和为 <code>sum</code> ，那么就有 <code>sum-neg-neg=target</code> ，那么就有 <code>neg=(sum-neg)/2</code> 此处 <code>sum&lt;target</code> 或 <code>(sum-target)%2==1</code> 说明没有可行方案。</p><p>那么讲问题转化为：将容量为 <code>neg</code> 的背包装满有多少种方案。依旧是使用基于滚动数组的动态规划实现，先便利物品在遍历背包，背包从后向前遍历。此处主要是递推公式存在区别 <code>dp[j]=dp[j]+dp[j-nums[i]]</code> 此处的含义在于：包含的方案有在第 <code>i</code> 次迭代时，不选择 <code>nums[i]</code> 的方案 <code>dp[j]</code> 和选择 <code>nums[i]</code> 的方案 <code>dp[j-nums[i]]</code></p><h2 id="LeetCode-474-一和零"><a href="#LeetCode-474-一和零" class="headerlink" title="LeetCode 474 一和零"></a>LeetCode 474 一和零</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中最多有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集 。</p><p>此处也是一个0/1背包问题，但是将背包的容量转变为了2维，此处每一个物品的价值都为1，那么创建一个二维数组，基于滚动数组的方式实现。那么依旧是在第 <code>k</code> 次迭代中，在元素 <code>0-k</code> 中进行选择。递推公式 <code>dp[i][j]=max(dp[i][j],dp[i-k0][j-k1]+1)</code> 也就是在第 <code>k</code> 迭代中，比较选取元素 <code>strs[k]</code> 或者不选择，哪一个能够获得最大长度。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/0-1%E8%83%8C%E5%8C%85/">0/1背包</category>
      
      
      <comments>http://marksblog.cn/posts/39479a98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-377-组合总和Ⅳ</title>
      <link>http://marksblog.cn/posts/34469175/</link>
      <guid>http://marksblog.cn/posts/34469175/</guid>
      <pubDate>Sun, 28 May 2023 09:20:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处就是一个完全背包问题，但是背包的最优化问题是最多的方案数。并且在题中指出了，顺序不同的序列将会被视为不同的组合，也就是此处元素的选择上是有序的。那么采取滚动数组的方式来实现，需要先遍历背包，再遍历元素，因为只有这样才能保证选取上的有序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[target+1]&lt;/code&gt; 表示总和为 &lt;code&gt;target&lt;/code&gt; 的元素选择方案个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在 &lt;code&gt;j&lt;/code&gt; 次迭代中，从元素 &lt;code&gt;0-n&lt;/code&gt; 中进行选择，那么相较于前面的方案，主要是背包容量增大。那么 &lt;code&gt;dp[j]=dp[j]+dp[j-nums[i]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始时，装满 &lt;code&gt;dp[0]&lt;/code&gt; 的方案有一种，那么 &lt;code&gt;dp[0]=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处是先遍历背包再遍历物品，那么先从前向后遍历背包再从前向后遍历物品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=&amp;#123;1,2,3&amp;#125; , target=4&lt;/code&gt; 动态规划的过程为:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={1,0,0,0,0}&lt;br&gt;    dp={1,1,0,0,0}&lt;br&gt;    dp={1,1,2,0,0}&lt;br&gt;    dp={1,1,2,4,0}&lt;br&gt;    dp={1,1,2,4,7}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-377-组合总和Ⅳ"><a href="#LeetCode-377-组合总和Ⅳ" class="headerlink" title="LeetCode 377 组合总和Ⅳ"></a>LeetCode 377 组合总和Ⅳ</h1><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和 Ⅳ</a></p><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>此处 <code>nums</code> 中的元素可以使用无限次。</p><p>示例：</p><blockquote><p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处就是一个完全背包问题，但是背包的最优化问题是最多的方案数。并且在题中指出了，顺序不同的序列将会被视为不同的组合，也就是此处元素的选择上是有序的。那么采取滚动数组的方式来实现，需要先遍历背包，再遍历元素，因为只有这样才能保证选取上的有序。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[target+1]</code> 表示总和为 <code>target</code> 的元素选择方案个数。</p></li><li><p>动态规划数组的推导：在 <code>j</code> 次迭代中，从元素 <code>0-n</code> 中进行选择，那么相较于前面的方案，主要是背包容量增大。那么 <code>dp[j]=dp[j]+dp[j-nums[i]]</code></p></li><li><p>动态规划数组的初始化：在初始时，装满 <code>dp[0]</code> 的方案有一种，那么 <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：此处是先遍历背包再遍历物品，那么先从前向后遍历背包再从前向后遍历物品。</p></li><li><p>举例验证：对于 <code>nums=&#123;1,2,3&#125; , target=4</code> 动态规划的过程为:</p></li></ol><blockquote><p>  dp={1,0,0,0,0}<br>    dp={1,1,0,0,0}<br>    dp={1,1,2,0,0}<br>    dp={1,1,2,4,0}<br>    dp={1,1,2,4,7}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i] &amp;&amp; dp[j]&lt;INT_MAX-dp[j-nums[i]]) dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于本题的测试用例，LeetCode官方给定的测试用例存在一定问题，会有整数溢出的问题，因此需要加上： <code>dp[j]&lt;INT_MAX-dp[j-nums[i]]</code></p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/34469175/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-518-零钱兑换II</title>
      <link>http://marksblog.cn/posts/d4a2a498/</link>
      <guid>http://marksblog.cn/posts/d4a2a498/</guid>
      <pubDate>Fri, 26 May 2023 12:58:11 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题是一个经典的完全背包的变体，此时背包的容量就是 &lt;code&gt;amount&lt;/code&gt; ，物品的重量为 &lt;code&gt;coins&lt;/code&gt; ，求解物品将背包装满的方案数。不同于之前0/1背包问题的变体（&lt;a href=&quot;https://leetcode.cn/problems/target-sum/&quot;&gt;494.目标和&lt;/a&gt;），此处的硬币数量是无限的，并且是完全对于硬币做加法的。&lt;/p&gt;
&lt;p&gt;那么这样的完全背包问题就适用于动态规划求解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[amount+1]&lt;/code&gt; 表示在背包容量为 &lt;code&gt;amount&lt;/code&gt; 时，将背包装满的方案数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，考虑元素 &lt;code&gt;coins[i]&lt;/code&gt; ，可以选取 0/n 个元素 &lt;code&gt;coins[i]&lt;/code&gt; ，那么递推公式为 &lt;code&gt;dp[j]=dp[j]+dp[j-coins[i]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初识时在元素 &lt;code&gt;coins[0]&lt;/code&gt; 中选取元素尝试装满背包，那么对于元素 &lt;code&gt;coins[0]&lt;/code&gt; 的倍数容量的背包就都能够被装满，也就是存在一种可行的方案。 &lt;code&gt;for(int i=0;i*coins[0]&amp;lt;=amount;i++)  dp[i*coins[0]]=1;&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处采取先遍历硬币再遍历背包的方式，遍历的顺序都是从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;coins=&amp;#123;1,2,5&amp;#125;,amount=5&lt;/code&gt; 动态规划数组的变化为：验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={1,1,1,1,1,1}&lt;br&gt;    dp={1,1,2,2,3,3}&lt;br&gt;    dp={1,1,2,2,3,4}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-518-零钱兑换II"><a href="#LeetCode-518-零钱兑换II" class="headerlink" title="LeetCode 518 零钱兑换II"></a>LeetCode 518 零钱兑换II</h1><p><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合32位带符号整数。</p><p>示例：</p><blockquote><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题是一个经典的完全背包的变体，此时背包的容量就是 <code>amount</code> ，物品的重量为 <code>coins</code> ，求解物品将背包装满的方案数。不同于之前0/1背包问题的变体（<a href="https://leetcode.cn/problems/target-sum/">494.目标和</a>），此处的硬币数量是无限的，并且是完全对于硬币做加法的。</p><p>那么这样的完全背包问题就适用于动态规划求解：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[amount+1]</code> 表示在背包容量为 <code>amount</code> 时，将背包装满的方案数</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，考虑元素 <code>coins[i]</code> ，可以选取 0/n 个元素 <code>coins[i]</code> ，那么递推公式为 <code>dp[j]=dp[j]+dp[j-coins[i]]</code></p></li><li><p>动态规划数组的初始化：在初识时在元素 <code>coins[0]</code> 中选取元素尝试装满背包，那么对于元素 <code>coins[0]</code> 的倍数容量的背包就都能够被装满，也就是存在一种可行的方案。 <code>for(int i=0;i*coins[0]&lt;=amount;i++)  dp[i*coins[0]]=1;</code> </p></li><li><p>动态规划数组的遍历顺序：此处采取先遍历硬币再遍历背包的方式，遍历的顺序都是从前向后遍历。</p></li><li><p>举例验证：对于 <code>coins=&#123;1,2,5&#125;,amount=5</code> 动态规划数组的变化为：验证正确</p></li></ol><blockquote><p>  dp={1,1,1,1,1,1}<br>    dp={1,1,2,2,3,3}<br>    dp={1,1,2,2,3,4}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*coins[<span class="number">0</span>]&lt;=amount;i++)</span><br><span class="line">            dp[i*coins[<span class="number">0</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对换遍历顺序：先遍历背包，再遍历物品，也就是初始的背包容量为0，那么 <code>dp[0]=1</code> 。逐步增加背包的容量，每一次计算的是，背包容量为 <code>j</code> 时，将背包装满的最大方案数。采取： <code>dp[j]=j&gt;=coins[i]?dp[j]+dp[j-coins[i]]:dp[j];</code> 的方式去递推，这样的递推方式存在一个问题，将单纯的选择问题转换为了有序的，这样的计算方式：在当前尝试选择元素 <code>coins[i]</code> ，例如对于 <code>dp[3]</code> 机会出现： <code>dp[3]=dp[1]+dp[2]</code> 此处将方案：<code>1，2 和 2，1</code> 进行了重复计算。因此在本题中遍历的顺序需要是先遍历物品在遍历背包。</p><p>关于遍历的顺序：</p><ul><li>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</li><li>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</li></ul>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/d4a2a498/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>完全背包问题</title>
      <link>http://marksblog.cn/posts/5cdb273d/</link>
      <guid>http://marksblog.cn/posts/5cdb273d/</guid>
      <pubDate>Fri, 26 May 2023 12:57:05 GMT</pubDate>
      
      <description>&lt;p&gt;多重背包问题的关键：在于对于每一个物体可以选择多次，在基于滚动数组的实现中，为了避免重复选择同一元素，在对背包的内层循环过程中采取从右向左的方式。那么在完全背包中要实现重复选择只需要将背包的内层循环从左向右进行即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[W+1]&lt;/code&gt; 表示，容量为 &lt;code&gt;W&lt;/code&gt; 的背包能够装下的物品的最高价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：每次尝试将元素 &lt;code&gt;i&lt;/code&gt; 转入到背包中看能否使得价值上升 &lt;code&gt;dp[j]=max(dp[j],dp[j-weight[i]]+value[i])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：初始时，未将物品装入到背包中，背包中的价值全部为 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在内外层循环中，既可以先遍历物品也可以先遍历背包，但是不论是对物品还是背包容量的遍历都需要从前向后进行。对于先遍历物品再遍历背包的理解：不断增加背包可选择的物品，在每一次添加物品后可以选择0或n个当前物品，将全部的物品都考虑到之后所得就是当前背包能够得到的最有化解。对于先遍历背包再遍历物品的理解：不断增加的是背包的容量，对于每一个背包容量，求解的是小容量的完全背包问题。（本质上就是一个减少物品的个数，一个减少背包的容量，从两个角度去划分子问题）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>有N件物品和一个最多能背重量为 <code>W</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p><p>相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 <code>n</code> 个物品可供选择。</p><p>假设背包的容量为4，重量和价值数组分别为： <code>weight=&#123;1,3,4&#125;,value=&#123;15,20,30&#125;</code></p><p>此时需要求解背包能够装下的最大价值的物品。</p><p>多重背包问题的关键：在于对于每一个物体可以选择多次，在基于滚动数组的实现中，为了避免重复选择同一元素，在对背包的内层循环过程中采取从右向左的方式。那么在完全背包中要实现重复选择只需要将背包的内层循环从左向右进行即可。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[W+1]</code> 表示，容量为 <code>W</code> 的背包能够装下的物品的最高价值。</p></li><li><p>动态规划数组的推导：每次尝试将元素 <code>i</code> 转入到背包中看能否使得价值上升 <code>dp[j]=max(dp[j],dp[j-weight[i]]+value[i])</code></p></li><li><p>动态规划数组的初始化：初始时，未将物品装入到背包中，背包中的价值全部为 <code>0</code></p></li><li><p>动态规划数组的遍历顺序：在内外层循环中，既可以先遍历物品也可以先遍历背包，但是不论是对物品还是背包容量的遍历都需要从前向后进行。对于先遍历物品再遍历背包的理解：不断增加背包可选择的物品，在每一次添加物品后可以选择0或n个当前物品，将全部的物品都考虑到之后所得就是当前背包能够得到的最有化解。对于先遍历背包再遍历物品的理解：不断增加的是背包的容量，对于每一个背包容量，求解的是小容量的完全背包问题。（本质上就是一个减少物品的个数，一个减少背包的容量，从两个角度去划分子问题）</p></li></ol><p>先遍历物品，再遍历背包的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vectr&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;value.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=weight[i];j&lt;=W;j++)&#123; <span class="comment">// 此处需要从weight[i]开始</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先遍历背包再遍历物品的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vectr&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weight.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[j]=j&gt;=weight[i]?<span class="built_in">max</span>(dp[j],dp[j-weight[i]]+value[i]):dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/5cdb273d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-474-一和零</title>
      <link>http://marksblog.cn/posts/cc66f981/</link>
      <guid>http://marksblog.cn/posts/cc66f981/</guid>
      <pubDate>Thu, 25 May 2023 12:15:16 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;问题的要求：寻找数组的子集，在子集中最多包含 &lt;code&gt;m&lt;/code&gt; 个 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;1&lt;/code&gt; ，使得子集中的元素尽可能的多。&lt;/p&gt;
&lt;p&gt;此处完全就是一个0/1背包问题，背包的容量为： &lt;code&gt;m&lt;/code&gt; 个 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;1&lt;/code&gt; ，每一个物品的价值都是1，要装下尽可能多的物品。将背包的维度从原本的一维情形转变成了2维。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[m+1][n+1]&lt;/code&gt; ，其中 &lt;code&gt;dp[i][j]&lt;/code&gt; 表示能装 &lt;code&gt;i&lt;/code&gt; 个 &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 个 &lt;code&gt;1&lt;/code&gt; 的背包能够放下的物品个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;k&lt;/code&gt; 次迭代中，在 &lt;code&gt;0-k&lt;/code&gt; 个元素中进行选择，相较于上一次迭代，新增了第 &lt;code&gt;k&lt;/code&gt; 个元素，记第 &lt;code&gt;k&lt;/code&gt; 个元素中 &lt;code&gt;0&lt;/code&gt; 的个数为 &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.375ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;2.166ex&quot; height=&quot;1.945ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -694 957.6 859.6&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt; ， &lt;code&gt;1&lt;/code&gt; 的个数为 &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.339ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;2.166ex&quot; height=&quot;1.91ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -694 957.6 844&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt; ，此处有两种情况：可以选择元素 &lt;code&gt;k&lt;/code&gt; ，或者不选元素 &lt;code&gt;k&lt;/code&gt; ，应该在两者之中选择能够装下最多元素数量的情形，那么递推公式为： &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.462ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;13.651ex&quot; height=&quot;2.032ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -694 6033.9 898&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D456&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(622.8,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(1678.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtext&quot; transform=&quot;translate(2636.1,0)&quot;&gt;&lt;path data-c=&quot;A0&quot; d=&quot;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2886.1,0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3330.8,0)&quot;&gt;&lt;path data-c=&quot;1D457&quot; d=&quot;M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4020.6,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(5076.3,0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt; &lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;dp[i][j]=max(dp[i-k_0][j-k_1]+1,dp[i][j])&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始状态仅在元素 &lt;code&gt;0&lt;/code&gt; 中进行选择，那么对于 &lt;code&gt;dp[m][n]&lt;/code&gt; 首先全初始化为 &lt;code&gt;0&lt;/code&gt; ，对与 &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.462ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;13.086ex&quot; height=&quot;2.032ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -694 5783.9 898&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D456&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(622.8,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(1678.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2636.1,0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3080.8,0)&quot;&gt;&lt;path data-c=&quot;1D457&quot; d=&quot;M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3770.6,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(4826.3,0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D458&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(554,-150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt; 的 &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.566ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;10.691ex&quot; height=&quot;2.262ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -750 4725.6 1000&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D451&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(520,0)&quot;&gt;&lt;path data-c=&quot;1D45D&quot; d=&quot;M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1023,0)&quot;&gt;&lt;path data-c=&quot;5B&quot; d=&quot;M118 -250V750H255V710H158V-210H255V-250H118Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1301,0)&quot;&gt;&lt;path data-c=&quot;1D456&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1646,0)&quot;&gt;&lt;path data-c=&quot;5D&quot; d=&quot;M22 710V750H159V-250H22V-210H119V710H22Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1924,0)&quot;&gt;&lt;path data-c=&quot;5B&quot; d=&quot;M118 -250V750H255V710H158V-210H255V-250H118Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2202,0)&quot;&gt;&lt;path data-c=&quot;1D457&quot; d=&quot;M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2614,0)&quot;&gt;&lt;path data-c=&quot;5D&quot; d=&quot;M22 710V750H159V-250H22V-210H119V710H22Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3169.8,0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4225.6,0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：外层循环将元素逐个加入，从左向右遍历元素数组 &lt;code&gt;strs&lt;/code&gt; ，内层循环遍历动态规划数组，并且为了防止重复选择 &lt;code&gt;i,j&lt;/code&gt; 都需要从大到小进行遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-474-一和零"><a href="#LeetCode-474-一和零" class="headerlink" title="LeetCode 474 一和零"></a>LeetCode 474 一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中最多有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集 。</p><p>示例：</p><blockquote><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>问题的要求：寻找数组的子集，在子集中最多包含 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> ，使得子集中的元素尽可能的多。</p><p>此处完全就是一个0/1背包问题，背包的容量为： <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> ，每一个物品的价值都是1，要装下尽可能多的物品。将背包的维度从原本的一维情形转变成了2维。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[m+1][n+1]</code> ，其中 <code>dp[i][j]</code> 表示能装 <code>i</code> 个 <code>0</code> 、 <code>j</code> 个 <code>1</code> 的背包能够放下的物品个数。</p></li><li><p>动态规划数组的推导：在第 <code>k</code> 次迭代中，在 <code>0-k</code> 个元素中进行选择，相较于上一次迭代，新增了第 <code>k</code> 个元素，记第 <code>k</code> 个元素中 <code>0</code> 的个数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 957.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container> ， <code>1</code> 的个数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="1.91ex" role="img" focusable="false" viewBox="0 -694 957.6 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container> ，此处有两种情况：可以选择元素 <code>k</code> ，或者不选元素 <code>k</code> ，应该在两者之中选择能够装下最多元素数量的情形，那么递推公式为： <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="13.651ex" height="2.032ex" role="img" focusable="false" viewBox="0 -694 6033.9 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(1678.6,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mo" transform="translate(2886.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3330.8,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(4020.6,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(5076.3,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container> </p><script type="math/tex; mode=display">dp[i][j]=max(dp[i-k_0][j-k_1]+1,dp[i][j])</script></li><li><p>动态规划数组的初始化：在初始状态仅在元素 <code>0</code> 中进行选择，那么对于 <code>dp[m][n]</code> 首先全初始化为 <code>0</code> ，对与 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="13.086ex" height="2.032ex" role="img" focusable="false" viewBox="0 -694 5783.9 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(1678.6,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(2636.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3080.8,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(3770.6,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(4826.3,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container> 的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.691ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4725.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(1924,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(2614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(3169.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4225.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></p></li><li><p>动态规划数组的遍历顺序：外层循环将元素逐个加入，从左向右遍历元素数组 <code>strs</code> ，内层循环遍历动态规划数组，并且为了防止重复选择 <code>i,j</code> 都需要从大到小进行遍历。</p></li></ol><ol><li>举例验证：对于 <code>strs = ["10", "0", "1"], m = 1, n = 1</code> 动态规划数组的求解过程为：验证正确。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">2</span>][<span class="number">2</span>]=[[<span class="number">0</span> <span class="number">0</span>], [<span class="number">0</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][<span class="number">2</span>]=[[<span class="number">0</span> <span class="number">1</span>], [<span class="number">0</span> <span class="number">1</span>]] </span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][<span class="number">2</span>]=[[<span class="number">0</span> <span class="number">1</span>], [<span class="number">1</span> <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>代码实现：(在本题中，动态规划数组可以全部初始化为0，外层循环从第 <code>0</code> 个元素开始选取，下述代码实现中采用这样的方式)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">string2nums</span><span class="params">(string &amp;s,<span class="type">int</span> &amp;n0,<span class="type">int</span> &amp;n1)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:s){</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="string">'0'</span>) n0++;</span><br><span class="line">            <span class="keyword">else</span> n1++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;strs.<span class="built_in">size</span>();k++){</span><br><span class="line">            <span class="type">int</span> n0=<span class="number">0</span>,n1=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string2nums</span>(strs[k],n0,n1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=dp.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=n0;i--){</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=dp[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=n1;j--){</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-n0][j-n1]+<span class="number">1</span>,dp[i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>().<span class="built_in">back</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/0-1%E8%83%8C%E5%8C%85/">0/1背包</category>
      
      
      <comments>http://marksblog.cn/posts/cc66f981/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
