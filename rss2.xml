<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mark&#39;s blogs</title>
    <link>http://marksblog.cn/</link>
    
    <atom:link href="http://marksblog.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>心之所向，行之可往</description>
    <pubDate>Mon, 05 Jun 2023 15:26:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode-121-买卖股票的最佳时机</title>
      <link>http://marksblog.cn/posts/3f336a0e/</link>
      <guid>http://marksblog.cn/posts/3f336a0e/</guid>
      <pubDate>Mon, 05 Jun 2023 15:25:56 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 &lt;code&gt;i&lt;/code&gt; 天买入，能够获得最大利润使用 &lt;code&gt;dp[i]&lt;/code&gt; 表示，那么第 &lt;code&gt;i+1&lt;/code&gt; 天买入能够获得的最大利润使用 &lt;code&gt;dp[i+1]&lt;/code&gt; 表示，那么 &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt; ，那么使用动态规划进行求解的过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 天买入能够获得的最大利润&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导： &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 &lt;code&gt;dp[n+1]=0&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在计算 &lt;code&gt;dp[n]&lt;/code&gt; 时需要使用 &lt;code&gt;dp[n+1]&lt;/code&gt; 的信息，因此此处需要使用从后向前遍历的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;code&gt;vector&amp;lt;int&amp;gt; prices=&amp;#123;7,1,5,3,6,4&amp;#125;;&lt;/code&gt; 动态规划数组的输出为： &lt;code&gt;dp=[0,0,3,1,5,0]&lt;/code&gt; 验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121 买卖股票的最佳时机"></a>LeetCode 121 买卖股票的最佳时机</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>示例</p><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 <code>i</code> 天买入，能够获得最大利润使用 <code>dp[i]</code> 表示，那么第 <code>i+1</code> 天买入能够获得的最大利润使用 <code>dp[i+1]</code> 表示，那么 <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code> ，那么使用动态规划进行求解的过程为：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示第 <code>n</code> 天买入能够获得的最大利润</p></li><li><p>动态规划数组的推导： <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code></p></li><li><p>动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 <code>dp[n+1]=0</code> </p></li><li><p>动态规划数组的遍历顺序：在计算 <code>dp[n]</code> 时需要使用 <code>dp[n+1]</code> 的信息，因此此处需要使用从后向前遍历的方式。</p></li><li><p>对于 <code>vector&lt;int&gt; prices=&#123;7,1,5,3,6,4&#125;;</code> 动态规划数组的输出为： <code>dp=[0,0,3,1,5,0]</code> 验证正确</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>]+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处仅仅使用到了前一天的状态，那么可以基于滚动数组实现，从而减少空间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            n1=<span class="built_in">max</span>(n0+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,n1);</span><br><span class="line">            n0=n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>本质上就是在一个数组中，寻找两个点之间的最大间距，使用一个双for循环即可完成穷举。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,prices[j]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式将会超出时间限制。</p><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>最简单的思想就是，在左边找到一个最小值，在右边找到一个最大值，做减法即可得到需要求解的值。</p><p>在左边寻找最小值的过程，本质上就是在从左向右遍历的过程中记录最小值，让当前值始终与记录的最小值做减法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minp=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minp=<span class="built_in">min</span>(minp,prices[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,prices[i]-minp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/3f336a0e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-337-打家劫舍III</title>
      <link>http://marksblog.cn/posts/1aa3096f/</link>
      <guid>http://marksblog.cn/posts/1aa3096f/</guid>
      <pubDate>Mon, 05 Jun 2023 14:31:28 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;深度优先&quot;&gt;&lt;a href=&quot;#深度优先&quot; class=&quot;headerlink&quot; title=&quot;深度优先&quot;&gt;&lt;/a&gt;深度优先&lt;/h2&gt;&lt;p&gt;改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。&lt;/p&gt;
&lt;p&gt;暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;robTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 计算对于以root为根节点能够抢到的最大的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 当前节点非空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val1=root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;left) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;right) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val2=&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(val1,val2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。&lt;/p&gt;
&lt;p&gt;记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 &lt;code&gt;robTree(root-&amp;gt;left)&lt;/code&gt; 的时候就重复计算了 &lt;code&gt;(robTree(root-&amp;gt;left-&amp;gt;left)+robTree(root-&amp;gt;left-&amp;gt;right))&lt;/code&gt; ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-337-打家劫舍III"><a href="#LeetCode-337-打家劫舍III" class="headerlink" title="LeetCode 337 打家劫舍III"></a>LeetCode 337 打家劫舍III</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍III</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例：</p><p><img src="img/打家劫舍III.png" alt="打家劫舍III"></p><blockquote><p>  输入: root = [3,2,3,null,3,null,1]<br>    输出: 7<br>    解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p></blockquote><h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。</p><p>暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123; <span class="comment">// 计算对于以root为根节点能够抢到的最大的值</span></span><br><span class="line">        <span class="keyword">if</span>(root)&#123; <span class="comment">// 当前节点非空</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="type">int</span> val1=root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) val1+=(<span class="built_in">robTree</span>(root-&gt;left-&gt;left)+<span class="built_in">robTree</span>(root-&gt;left-&gt;right));</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) val1+=(<span class="built_in">robTree</span>(root-&gt;right-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right-&gt;right));</span><br><span class="line">            <span class="type">int</span> val2=<span class="built_in">robTree</span>(root-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(val1,val2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">robTree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。</p><p>记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 <code>robTree(root-&gt;left)</code> 的时候就重复计算了 <code>(robTree(root-&gt;left-&gt;left)+robTree(root-&gt;left-&gt;right))</code> ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode* , <span class="type">int</span>&gt; umap; <span class="comment">// 记录计算过的结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (umap[root]) <span class="keyword">return</span> umap[root]; <span class="comment">// 如果umap里已经有记录则直接返回</span></span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="type">int</span> val1 = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) val1 += <span class="built_in">rob</span>(root-&gt;left-&gt;left) + <span class="built_in">rob</span>(root-&gt;left-&gt;right); <span class="comment">// 跳过root-&gt;left</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) val1 += <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right); <span class="comment">// 跳过root-&gt;right</span></span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right); <span class="comment">// 考虑root的左右孩子</span></span><br><span class="line">        umap[root] = <span class="built_in">max</span>(val1, val2); <span class="comment">// umap记录一下结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处的动态规划实现，基本上和记忆化搜索类似。也是在递归的基础上实现。进行动态规划的基本思路依旧是：对于以 <code>root</code> 为根的子树，能够选取到的最大的节点数值总和为，max(选取当前节点+两棵子树后代的最大值，不选当前节点两棵子树的最大值之和) 。</p><p>此处需要基于动态规划实现，并且要避免重复的计算操作，那么使用一个递归函数，返回一个长度为2的数组，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p><ol><li><p>动态规划数组的定义：对于递归函数 <code>robTree(TreeNode* root)</code>，返回 <code>vector&lt;int&gt; dp(2)</code> ，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p></li><li><p>动态规划数组的推导：在当前的递归函数层中，需要计算的有两个值，其中 <code>dp[0]</code> 表示的是选取根节点能够获取到的最大值，那么左右孩子节点是一定不能够选取的 <code>dp[0]=root-&gt;val+robTree(root-&gt;left)[1]+robTree(root-&gt;right)[1]</code> ，对于<code>dp[1]</code> 表示的是不选取根节点能够获取到的最大值，此时左右孩子节点是可选可不选的，那么具体能否进行选取，取决那种方式能够获取到更大的值 <code>dp[1]=max(robTree(root-&gt;left)[0],robTree(root-&gt;left)[1])+max(robTree(root-&gt;right)[0],robTree(root-&gt;right)[1])</code></p></li><li><p>动态规划数组的初始化：对于空节点 <code>robTree(nullptr)=&#123;0,0&#125;</code></p></li><li><p>动态规划数组的遍历顺序：本质上就是DFS，并且对于根节点而言是后序遍历</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            res[<span class="number">0</span>]=root-&gt;val+val1[<span class="number">1</span>]+val2[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>]=<span class="built_in">max</span>(val1[<span class="number">0</span>],val1[<span class="number">1</span>])+<span class="built_in">max</span>(val2[<span class="number">0</span>],val2[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在动态规划的过程中，采取的是后序遍历的方式，上层节点的值是在底层节点的值完成计算后，才得到的，并且使用一个vector数组同时记录了选取根节点和不选取根节点的最优解。但是由于在递归函数的返回值中使用的是vector数组，vector数组在创建时将会预分配较大的内存空间，导致程序的开销较大，此处改用 <code>pair</code> ，将会使得LeetCode上的运行时间和内存空间大大降低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line">            res.first=root-&gt;val+val1.second+val2.second;</span><br><span class="line">            res.second=<span class="built_in">max</span>(val1.first,val1.second)+<span class="built_in">max</span>(val2.first,val2.second);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res.first,res.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/1aa3096f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-213-打家劫舍II</title>
      <link>http://marksblog.cn/posts/null/</link>
      <guid>http://marksblog.cn/posts/null/</guid>
      <pubDate>Sat, 03 Jun 2023 12:13:54 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题相较于&lt;a href=&quot;https://leetcode.cn/problems/house-robber/&quot;&gt;198.打家劫舍&lt;/a&gt;的主要区别在于，首尾的元素也成了相邻元素，导致元素成为了一个环，因此不能采取前面的方式计算。&lt;/p&gt;
&lt;p&gt;此处可以将问题进行转化：此处的首尾元素只有一个可以被选取，那么将问题划分为两部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不选取首元素，那么此时尾元素就可以选取，问题转化为在后n-1个元素不相邻选取最大值，求得res1&lt;/li&gt;
&lt;li&gt;不选取尾元素，那么此时首元素就可以选取，问题转化为在前n-1个元素不相邻选取最大值，求得res2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在得到res1和res2后，只需要选取其中较大的即可，在此基础上，使用动态规划求解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i]&lt;/code&gt; 表示在 &lt;code&gt;0-i&lt;/code&gt; 的元素中选取，能够得到的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：不选取当前元素 &lt;code&gt;i&lt;/code&gt; 那么 &lt;code&gt;i-1&lt;/code&gt; 是可以被选取(不代表一定选取)，选取当前元素 &lt;code&gt;i&lt;/code&gt; 那么 &lt;code&gt;i-1&lt;/code&gt; 不可选取，从 &lt;code&gt;dp[i-2]&lt;/code&gt; 计算 &lt;code&gt;dp[i]=max(dp[i-1],dp[i-2]+nums[i])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于情况2 &lt;code&gt;dp[0]=nums[0],dp[1]=max(nums[0],nums[1])&lt;/code&gt; ，对于情况1 &lt;code&gt;dp[0]=nums[1],dp[1]=max(nums[1],nums[2])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：需要使用前面的两个元素，从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=[2,3,2]&lt;/code&gt; 输出结果为 &lt;code&gt;3&lt;/code&gt; ，验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-213-打家劫舍II"><a href="#LeetCode-213-打家劫舍II" class="headerlink" title="LeetCode 213 打家劫舍II"></a>LeetCode 213 打家劫舍II</h1><p><a href="https://leetcode.cn/problems/house-robber-ii/">213.打家劫舍II</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例：</p><blockquote><p>  输入：nums = [2,3,2]<br>    输出：3<br>    解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题相较于<a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a>的主要区别在于，首尾的元素也成了相邻元素，导致元素成为了一个环，因此不能采取前面的方式计算。</p><p>此处可以将问题进行转化：此处的首尾元素只有一个可以被选取，那么将问题划分为两部分。</p><ol><li>不选取首元素，那么此时尾元素就可以选取，问题转化为在后n-1个元素不相邻选取最大值，求得res1</li><li>不选取尾元素，那么此时首元素就可以选取，问题转化为在前n-1个元素不相邻选取最大值，求得res2</li></ol><p>在得到res1和res2后，只需要选取其中较大的即可，在此基础上，使用动态规划求解：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示在 <code>0-i</code> 的元素中选取，能够得到的最大值</p></li><li><p>动态规划数组的推导：不选取当前元素 <code>i</code> 那么 <code>i-1</code> 是可以被选取(不代表一定选取)，选取当前元素 <code>i</code> 那么 <code>i-1</code> 不可选取，从 <code>dp[i-2]</code> 计算 <code>dp[i]=max(dp[i-1],dp[i-2]+nums[i])</code></p></li><li><p>动态规划数组的初始化：对于情况2 <code>dp[0]=nums[0],dp[1]=max(nums[0],nums[1])</code> ，对于情况1 <code>dp[0]=nums[1],dp[1]=max(nums[1],nums[2])</code></p></li><li><p>动态规划数组的遍历顺序：需要使用前面的两个元素，从前向后遍历</p></li><li><p>举例验证：对于 <code>nums=[2,3,2]</code> 输出结果为 <code>3</code> ，验证正确</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> n0=nums[<span class="number">0</span>],n1=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res1=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]),res2=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res1=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res1;</span><br><span class="line">        &#125;</span><br><span class="line">        n0=nums[<span class="number">1</span>],n1=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res2=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将求解非环状序列的操作封装为函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n0=nums[start],n1=<span class="built_in">max</span>(nums[start],nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res=n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">2</span>;i&lt;end;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res1=<span class="built_in">robRange</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> res2=<span class="built_in">robRange</span>(nums,<span class="number">1</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/null/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-198-打家劫舍</title>
      <link>http://marksblog.cn/posts/9b6273f5/</link>
      <guid>http://marksblog.cn/posts/9b6273f5/</guid>
      <pubDate>Sat, 03 Jun 2023 11:33:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[nums.size()+1]&lt;/code&gt; 表示在 &lt;code&gt;nums.size()&lt;/code&gt; 个物品中进行选取能够得到的最大的物品价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在 &lt;code&gt;j&lt;/code&gt; 个物品中选取，可以选取第 &lt;code&gt;j&lt;/code&gt; 个物品也可以不进行选取，那么 &lt;code&gt;dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 不存在可选元素， &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于 &lt;code&gt;dp[1]&lt;/code&gt; 只能选取第一个元素 &lt;code&gt;dp[1]=nums[0]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=[1,2,3,1]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp={0,1,0,0,0}&lt;br&gt;dp={0,1,2,0,0}&lt;br&gt;dp={0,1,2,4,0}&lt;br&gt;dp={0,1,2,4,4}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode 198 打家劫舍"></a>LeetCode 198 打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><blockquote><p>  输入：[1,2,3,1]<br>    输出：4<br>    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>        偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[nums.size()+1]</code> 表示在 <code>nums.size()</code> 个物品中进行选取能够得到的最大的物品价值。</p></li><li><p>动态规划数组的推导：在 <code>j</code> 个物品中选取，可以选取第 <code>j</code> 个物品也可以不进行选取，那么 <code>dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])</code></p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 不存在可选元素， <code>dp[0]=0</code> ，对于 <code>dp[1]</code> 只能选取第一个元素 <code>dp[1]=nums[0]</code> </p></li><li><p>动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。</p></li><li><p>举例验证：对于 <code>nums=[1,2,3,1]</code> </p></li></ol><blockquote><p>dp={0,1,0,0,0}<br>dp={0,1,2,0,0}<br>dp={0,1,2,4,0}<br>dp={0,1,2,4,4}</p></blockquote><p>验证正确。</p><p>此处在进行计算时，实际上只使用到了前两个元素的值，那么只需要常数的元素空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(n1,n0+nums[i<span class="number">-1</span>]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/9b6273f5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>完全背包问题总结</title>
      <link>http://marksblog.cn/posts/97265db6/</link>
      <guid>http://marksblog.cn/posts/97265db6/</guid>
      <pubDate>Fri, 02 Jun 2023 12:30:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;完全背包问题总结&quot;&gt;&lt;a href=&quot;#完全背包问题总结&quot; class=&quot;headerlink&quot; title=&quot;完全背包问题总结&quot;&gt;&lt;/a&gt;完全背包问题总结&lt;/h1&gt;&lt;p&gt;首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 &lt;code&gt;W&lt;/code&gt; 的背包。第 &lt;code&gt;i&lt;/code&gt; 件物品的重量是 &lt;code&gt;weight[i]&lt;/code&gt; ，得到的价值是 &lt;code&gt;value[i]&lt;/code&gt; 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。&lt;/p&gt;
&lt;p&gt;相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 &lt;code&gt;n&lt;/code&gt; 个物品可供选择（即从所有的物品中做任意的选择）。&lt;/p&gt;
&lt;p&gt;完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 &lt;code&gt;i&lt;/code&gt; 次迭代时，0/1背包只能使用一次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="完全背包问题总结"><a href="#完全背包问题总结" class="headerlink" title="完全背包问题总结"></a>完全背包问题总结</h1><p>首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 <code>W</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p><p>相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 <code>n</code> 个物品可供选择（即从所有的物品中做任意的选择）。</p><p>完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。</p><ol><li><p>对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 <code>i</code> 次迭代时，0/1背包只能使用一次物品 <code>weight[i]</code> ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 <code>weight[i]</code> ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）</p></li><li><p>先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。</p></li></ol><h2 id="LeetCode-377-组合总和Ⅳ"><a href="#LeetCode-377-组合总和Ⅳ" class="headerlink" title="LeetCode 377 组合总和Ⅳ"></a>LeetCode 377 组合总和Ⅳ</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和 Ⅳ</a></p><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>本题求解的并不是组合问题，是一个排序问题，在题目示例中将 <code>1,2,1</code> 和 <code>1,1,2</code> 视为两种不同的组合，也就是对于元素的选取顺序是敏感的。那么应该先遍历背包再遍历物品，并且此处求解的是恰好装满的情形，相应的递推公式为 <code>dp[j]+=dp[j-nums[i]]</code></p><h2 id="LeetCode-518-零钱兑换II"><a href="#LeetCode-518-零钱兑换II" class="headerlink" title="LeetCode 518 零钱兑换II"></a>LeetCode 518 零钱兑换II</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>根据题中的示例，本题求解的是一个组合问题。</p><p>并且此处的背包问题是一个恰好装满的情形，那么对于组合问题基本思路就是先遍历物品再遍历背包，那么递推公式为： <code>dp[j]+=dp[j-coins[i]]</code> ，在进行初始化是一定要将 <code>dp[0]=1</code> </p><h2 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode 322 零钱兑换"></a>LeetCode 322 零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>此处的最优化问题为：求解能够恰好装满背包的最少硬币数量，那么对于组合和排列都是相同的，两种遍历顺序都是可以的。基本的递推公式为：<code>dp[j]=min(dp[j],dp[j-coins[i]]+1)</code> ，要让上述递推公式成立，需要在数组的初始化时进行特殊处理，对于 <code>dp[0]</code> 只需要0个硬币即可装满。那么对于其他的值明显都装不满，因此初始为 <code>INT_MAX</code> ，并且每次判断 <code>dp[j-coins[i]]!=INT_MAX</code></p><h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>此处和上述问题是非常类似的，也是在求解将背包恰好装满的最少的元素数量。但是此处的元素要求是完全平方数，因此在遍历物品的同时去生成相应的完全平方数即可。对于 <code>dp[0]</code> 依旧是初始化为0。其他元素全部初始化为 <code>INT_MAX</code> 。对应的递推公式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 要求 <code>dp[j-nums[i]]!=INT_MAX</code></p><h2 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>此处需要注意的是：本题是一个排列问题，一定要先遍历背包，再遍历物品，也就是对于任意的背包大小都要能够使用全部的物品去进行填充，否则对于 <code>applepenapple</code> 这样的情形，在仅使用 <code>apple</code> 时，不能将后续的也标记为装满。那么在使用 <code>pen</code> 去填充时，无法使用 <code>apple</code> 将后续填满。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/97265db6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-139-单词拆分</title>
      <link>http://marksblog.cn/posts/4a1c4ee7/</link>
      <guid>http://marksblog.cn/posts/4a1c4ee7/</guid>
      <pubDate>Thu, 01 Jun 2023 00:58:59 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。&lt;/p&gt;
&lt;p&gt;此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）&lt;/p&gt;
&lt;p&gt;考虑这样一种情况： &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 那么先遍历物品，再遍历背包，初始时只能使用 &lt;code&gt;apple&lt;/code&gt; 那么只能将第一个 &lt;code&gt;apple&lt;/code&gt; 恰好装满，在第二次迭代中，是只考虑增加 &lt;code&gt;pen&lt;/code&gt; 的情形，但实际上还需要使用 &lt;code&gt;apple&lt;/code&gt; 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[s.size()+1]&lt;/code&gt; 表示长度为 &lt;code&gt;s.size()&lt;/code&gt; 的字符串能否恰好装满&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;j&lt;/code&gt; 次迭代中，判断字符从 &lt;code&gt;0-j-1&lt;/code&gt; 位置的字符串 &lt;code&gt;s&lt;/code&gt; 能否恰好装满，对于每一个物品 &lt;code&gt;wordDict[i]&lt;/code&gt; 都需要尝试从 &lt;code&gt;j-1&lt;/code&gt; 处向前装入试试，所以有：其中 &lt;code&gt;match&lt;/code&gt; 是字符串匹配操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(j&amp;gt;=wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dp[j]=dp[j]||(dp[j-wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()]&amp;amp;&amp;amp;&lt;span class=&quot;built_in&quot;&gt;match&lt;/span&gt;(s,j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,wordDict[i]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于&lt;code&gt;dp[0]&lt;/code&gt; 一定是能够恰好装满的，所以 &lt;code&gt;dp[0]=true&lt;/code&gt; 其他全部初始化为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 动态规划数组的推导过程为：验证成立&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,1,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h1><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例：</p><blockquote><p>  输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>    输出: true<br>    解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p></blockquote><ul><li>1 &lt;= <code>s.length</code> &lt;= 300</li><li>1 &lt;= <code>wordDict.length</code> &lt;= 1000</li><li>1 &lt;= <code>wordDict[i].length</code> &lt;= 20</li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 互不相同</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。</p><p>此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）</p><p>考虑这样一种情况： <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 那么先遍历物品，再遍历背包，初始时只能使用 <code>apple</code> 那么只能将第一个 <code>apple</code> 恰好装满，在第二次迭代中，是只考虑增加 <code>pen</code> 的情形，但实际上还需要使用 <code>apple</code> 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[s.size()+1]</code> 表示长度为 <code>s.size()</code> 的字符串能否恰好装满</p></li><li><p>动态规划数组的推导：在第 <code>j</code> 次迭代中，判断字符从 <code>0-j-1</code> 位置的字符串 <code>s</code> 能否恰好装满，对于每一个物品 <code>wordDict[i]</code> 都需要尝试从 <code>j-1</code> 处向前装入试试，所以有：其中 <code>match</code> 是字符串匹配操作。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：对于<code>dp[0]</code> 一定是能够恰好装满的，所以 <code>dp[0]=true</code> 其他全部初始化为 <code>false</code></p></li><li><p>动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式</p></li><li><p>举例验证：对于 <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 动态规划数组的推导过程为：验证成立</p></li></ol><blockquote><p>  1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,1,</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string&amp; s,<span class="type">int</span> j,string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i]!=s[j-word.<span class="built_in">size</span>()+<span class="number">1</span>+i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordDict.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/4a1c4ee7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-279-完全平方数</title>
      <link>http://marksblog.cn/posts/null/</link>
      <guid>http://marksblog.cn/posts/null/</guid>
      <pubDate>Tue, 30 May 2023 12:20:19 GMT</pubDate>
      
      <description>&lt;p&gt;将问题转化为完全背包问题，那么此处背包的容量就是 &lt;code&gt;n&lt;/code&gt; ，并没有给定相应的物品，但是要将背包 &lt;code&gt;n&lt;/code&gt; 装满，那么使用的物品就应该是 &lt;code&gt;1-n&lt;/code&gt; 中的全部完全平方数，首先创建物品数组。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; nums;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i*i&amp;lt;=n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nums.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(i*i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么此处的物品数组就是 &lt;code&gt;nums&lt;/code&gt; ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和&lt;a href=&quot;https://leetcode.cn/problems/coin-change/&quot;&gt;322.零钱兑换&lt;/a&gt;完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示总和为 &lt;code&gt;n&lt;/code&gt; 的最少的完全平方数的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，考虑元素 &lt;code&gt;nums[i]&lt;/code&gt; ，尝试使用 &lt;code&gt;nums[i]&lt;/code&gt; 来减少数量 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; （此处需要判断 &lt;code&gt;dp[j-nums[i]]!=INT_MAX&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于其他元素，由于递推方式为 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; 那么对于初始不能恰好装满的容量，都初始化为 &lt;code&gt;INT_MAX&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：&lt;code&gt;n=13&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h1><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例：</p><blockquote><p>  输入：n = 13<br>    输出：2<br>    解释：13 = 4 + 9</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题，那么此处背包的容量就是 <code>n</code> ，并没有给定相应的物品，但是要将背包 <code>n</code> 装满，那么使用的物品就应该是 <code>1-n</code> 中的全部完全平方数，首先创建物品数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此处的物品数组就是 <code>nums</code> ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和<a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a>完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示总和为 <code>n</code> 的最少的完全平方数的数量</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，考虑元素 <code>nums[i]</code> ，尝试使用 <code>nums[i]</code> 来减少数量 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> （此处需要判断 <code>dp[j-nums[i]]!=INT_MAX</code>）</p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 <code>dp[0]=0</code> ，对于其他元素，由于递推方式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 那么对于初始不能恰好装满的容量，都初始化为 <code>INT_MAX</code> 。</p></li><li><p>动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。</p></li><li><p>举例验证：<code>n=13</code> </p></li></ol><blockquote><p>  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums[i];j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-nums[i]]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-nums[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处的空间复杂度可优化，对于物品数组是可以不存储的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-i*i]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</category>
      
      
      <comments>http://marksblog.cn/posts/null/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-322-零钱兑换</title>
      <link>http://marksblog.cn/posts/d74e0b6/</link>
      <guid>http://marksblog.cn/posts/d74e0b6/</guid>
      <pubDate>Tue, 30 May 2023 02:17:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;不同于&lt;a href=&quot;https://leetcode.cn/problems/coin-change-ii/&quot;&gt;518.零钱兑换II&lt;/a&gt;，此处需要求解的是，使用最少的硬币个数得到整数 &lt;code&gt;amount&lt;/code&gt; ，此处的硬币数量是无限的。此处是一个组合问题，不存在选取顺序的问题。将之转化为完全背包问题：背包的容量为 &lt;code&gt;amount&lt;/code&gt; ，物品的重量为 &lt;code&gt;coins&lt;/code&gt; ，每一个物品的价值都为1，此处求解的是物品的最小价值。但是，此处的不同点在与，在向背包中装入物品时，要求将背包恰好装满。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义动态规划数组 &lt;code&gt;dp[amount+1]&lt;/code&gt; 表示将 &lt;code&gt;amount&lt;/code&gt; 装满所需的最少硬币个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，在硬币 &lt;code&gt;0-i&lt;/code&gt; 中进行选择，那么主要是 &lt;code&gt;coins[i]&lt;/code&gt; 的选择问题。此处在进行递推时，需要考虑到可行的条件。首先是 &lt;code&gt;dp[j]&lt;/code&gt; 的值，若是 &lt;code&gt;dp[j]=-1&lt;/code&gt; 说明之前不存在方案将之装满，那么就需要查看 &lt;code&gt;dp[j-coins[i]]&lt;/code&gt; 的值是否为 &lt;code&gt;-1&lt;/code&gt; ，若是为说明当前依旧无法装满，不修改值，负责当前存在从 &lt;code&gt;dp[j-coins[i]]&lt;/code&gt; 的基础上将之装满的方案，对应需要的最少硬币数就是 &lt;code&gt;dp[j-coins[i]]+1&lt;/code&gt; ，若是 &lt;code&gt;dp[j]!=-1&lt;/code&gt; ，说明当前就存在可以装满的方案，那么尝试装入 &lt;code&gt;coins[i]&lt;/code&gt; 看能否更少，当然需要 &lt;code&gt;dp[j-coins[i]]!=-1&lt;/code&gt; ，那么总体的推导过程就是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j-coins[i]]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[j]=&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;(dp[j],dp[j-coins[i]]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dp[j-coins[i]]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[j]=dp[j-coins[i]]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始时全部初始为 &lt;code&gt;-1&lt;/code&gt; 表示不存在装满的方案，而对于 &lt;code&gt;dp[0]&lt;/code&gt; 装满0的背包，只需要0个硬币，初始化为 &lt;code&gt;dp[0]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处先遍历物品，再遍历背包，并且在对背包遍历时从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证： &lt;code&gt;coins = [1, 2, 5], amount = 11&lt;/code&gt; 那么动态规划数组的推导过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;    dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11}&lt;br&gt;    dp={0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6}&lt;br&gt;    dp={0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3}&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode 322 零钱兑换"></a>LeetCode 322 零钱兑换</h1><p><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例：</p><blockquote><p>输入：coins = [1, 2, 5], amount = 11<br> 输出：3<br> 解释：11 = 5 + 5 + 1</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>不同于<a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a>，此处需要求解的是，使用最少的硬币个数得到整数 <code>amount</code> ，此处的硬币数量是无限的。此处是一个组合问题，不存在选取顺序的问题。将之转化为完全背包问题：背包的容量为 <code>amount</code> ，物品的重量为 <code>coins</code> ，每一个物品的价值都为1，此处求解的是物品的最小价值。但是，此处的不同点在与，在向背包中装入物品时，要求将背包恰好装满。</p><ol><li><p>动态规划数组的定义：定义动态规划数组 <code>dp[amount+1]</code> 表示将 <code>amount</code> 装满所需的最少硬币个数。</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，在硬币 <code>0-i</code> 中进行选择，那么主要是 <code>coins[i]</code> 的选择问题。此处在进行递推时，需要考虑到可行的条件。首先是 <code>dp[j]</code> 的值，若是 <code>dp[j]=-1</code> 说明之前不存在方案将之装满，那么就需要查看 <code>dp[j-coins[i]]</code> 的值是否为 <code>-1</code> ，若是为说明当前依旧无法装满，不修改值，负责当前存在从 <code>dp[j-coins[i]]</code> 的基础上将之装满的方案，对应需要的最少硬币数就是 <code>dp[j-coins[i]]+1</code> ，若是 <code>dp[j]!=-1</code> ，说明当前就存在可以装满的方案，那么尝试装入 <code>coins[i]</code> 看能否更少，当然需要 <code>dp[j-coins[i]]!=-1</code> ，那么总体的推导过程就是：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">        dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：在初始时全部初始为 <code>-1</code> 表示不存在装满的方案，而对于 <code>dp[0]</code> 装满0的背包，只需要0个硬币，初始化为 <code>dp[0]=0</code></p></li><li><p>动态规划数组的遍历顺序：此处先遍历物品，再遍历背包，并且在对背包遍历时从前向后遍历。</p></li><li><p>举例验证： <code>coins = [1, 2, 5], amount = 11</code> 那么动态规划数组的推导过程为：</p></li></ol><p>&gt;<br>    dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11}<br>    dp={0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6}<br>    dp={0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3}</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">                        dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">-1</span>)</span><br><span class="line">                        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/d74e0b6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>01背包问题总结</title>
      <link>http://marksblog.cn/posts/39479a98/</link>
      <guid>http://marksblog.cn/posts/39479a98/</guid>
      <pubDate>Sun, 28 May 2023 09:21:41 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;01背包问题总结&quot;&gt;&lt;a href=&quot;#01背包问题总结&quot; class=&quot;headerlink&quot; title=&quot;01背包问题总结&quot;&gt;&lt;/a&gt;01背包问题总结&lt;/h1&gt;&lt;p&gt;首先，需要清楚的是0/1背包问题本身：有 &lt;code&gt;n&lt;/code&gt; 件物品和一个最多能背重量为 &lt;code&gt;w&lt;/code&gt; 的背包。第 &lt;code&gt;i&lt;/code&gt; 件物品的重量是 &lt;code&gt;weight[i]&lt;/code&gt; ，得到的价值是 &lt;code&gt;value[i]&lt;/code&gt; 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。&lt;/p&gt;
&lt;p&gt;此处使用动态规划求解，问题的划分方式为：使用一个二维数组对问题进行两部分的划分。对于 &lt;code&gt;dp[i][j]&lt;/code&gt; 求解的是，当背包容量为 &lt;code&gt;j&lt;/code&gt; 时，在物品 &lt;code&gt;0-i&lt;/code&gt; 中选择能够获取到的最大的容量。&lt;/p&gt;
&lt;p&gt;那么在采取逐行遍历的方式，就是每一次增加物品的数量，递推公式为： &lt;code&gt;dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;采取逐列遍历的方式，每一次增加的是背包的容量，那么递推公式为： &lt;code&gt;dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用滚动数组实现动态规划的过程：基于背包容量的滚动数组实现，那么此处就一定要先遍历物品再遍历背包了，因为动态规划数组的含义是，在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，使用 &lt;code&gt;0-i&lt;/code&gt; 个物品去填充背包，能够得到的背包中物品的最大价值。并且是0/1背包问题，那么对于背包的遍历顺序一定要是&lt;/p&gt;
&lt;p&gt;能否基于物品数量的滚动数组实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n]&lt;/code&gt; ，在初始时表示，当背包容量为0时，能够装下的最大的物品价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：对于第 &lt;code&gt;j&lt;/code&gt; 次迭代时，表示当背包容量为 &lt;code&gt;j&lt;/code&gt; 时，能够装下的物品的最大价值。在一维的情形下，背包容量减去 &lt;code&gt;weight[i]&lt;/code&gt; 的情形无法实现递推。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此在0/1背包中使用滚动数组，只能基于背包容量的数组来实现。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="01背包问题总结"><a href="#01背包问题总结" class="headerlink" title="01背包问题总结"></a>01背包问题总结</h1><p>首先，需要清楚的是0/1背包问题本身：有 <code>n</code> 件物品和一个最多能背重量为 <code>w</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p>此处使用动态规划求解，问题的划分方式为：使用一个二维数组对问题进行两部分的划分。对于 <code>dp[i][j]</code> 求解的是，当背包容量为 <code>j</code> 时，在物品 <code>0-i</code> 中选择能够获取到的最大的容量。</p><p>那么在采取逐行遍历的方式，就是每一次增加物品的数量，递推公式为： <code>dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])</code></p><p>采取逐列遍历的方式，每一次增加的是背包的容量，那么递推公式为： <code>dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])</code></p><p>使用滚动数组实现动态规划的过程：基于背包容量的滚动数组实现，那么此处就一定要先遍历物品再遍历背包了，因为动态规划数组的含义是，在第 <code>i</code> 次迭代中，使用 <code>0-i</code> 个物品去填充背包，能够得到的背包中物品的最大价值。并且是0/1背包问题，那么对于背包的遍历顺序一定要是</p><p>能否基于物品数量的滚动数组实现：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n]</code> ，在初始时表示，当背包容量为0时，能够装下的最大的物品价值。</p></li><li><p>动态规划数组的推导：对于第 <code>j</code> 次迭代时，表示当背包容量为 <code>j</code> 时，能够装下的物品的最大价值。在一维的情形下，背包容量减去 <code>weight[i]</code> 的情形无法实现递推。</p></li></ol><p>因此在0/1背包中使用滚动数组，只能基于背包容量的数组来实现。</p><h2 id="LeetCode-416-分割等和子集"><a href="#LeetCode-416-分割等和子集" class="headerlink" title="LeetCode 416 分割等和子集"></a>LeetCode 416 分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416.分割等和子集</a></p><p>给你一个只包含正整数的非空数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>此处的重点是问题的转化，要求两个子集的元素和相等，将元素的和转化为背包的大小，也就是使用一个容量等于全部元素和一半的背包去装数组元素能否恰好将背包装满。这一半能够装满，那么另外一半也能够装满。也就完成了划分。</p><p>动态规划数组的定义为： <code>dp[j]</code> 表示：当背包容量为 <code>j</code> 时，能够恰好将背包装满，那么递推公式就为：在第 <code>i</code> 次迭代中在 <code>0-i</code> 个元素中进行选择，<code>dp[j]=dp[j]||dp[j-nums[i]]</code> 此处的背包也是需要从后向前遍历，为了防止重复选择。</p><p>本题的重点在于问题的转化，将等和子集划分，转化为一个0/1背包问题。</p><h2 id="LeetCode-1049-最后一块石头的重量II"><a href="#LeetCode-1049-最后一块石头的重量II" class="headerlink" title="LeetCode 1049 最后一块石头的重量II"></a>LeetCode 1049 最后一块石头的重量II</h2><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049.最后一块石头的重量II</a></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code> 。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code> ，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code> ，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code> 。</li></ul><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。</p><p>本题的求解方式也是需要对问题进行转化，两块石头粉碎后的重量一定是小重量石头的两倍，那问题就像是一个消消乐游戏。那么想要找到最优的方案，就是将石头划分为两个集合，这两个集合的石头总重量要尽可能的接近。</p><p>最接近的划分方式就是：两个集合的总重量恰好为全部石头总重量的一半，转为背包容量为sum/2，能否将背包恰好装满。定义动态规划数组 <code>dp[sum/2+1]</code> ，表示能否恰好将 <code>sum/2</code> 容量的背包装满，那么最后只要找到能够恰好装满的最大容量的背包即可。问题和分割等和子集类似。</p><h2 id="LeetCode-494-目标和"><a href="#LeetCode-494-目标和" class="headerlink" title="LeetCode 494 目标和"></a>LeetCode 494 目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">494.目标和</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>+</code> 或 <code>-</code> ，然后串联起所有整数，可以构造一个表达式：</p><p>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>+</code> ，在 <code>1</code> 之前添加 <code>-</code> ，然后串联起来得到表达式 <code>+2-1</code> 。<br>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同表达式的数目。</p><p>本题对于问题的转化是相对复杂的：首先，假设在表达式中为负号元素的总和为 <code>neg</code> ，所有元素的总和为 <code>sum</code> ，那么就有 <code>sum-neg-neg=target</code> ，那么就有 <code>neg=(sum-neg)/2</code> 此处 <code>sum&lt;target</code> 或 <code>(sum-target)%2==1</code> 说明没有可行方案。</p><p>那么讲问题转化为：将容量为 <code>neg</code> 的背包装满有多少种方案。依旧是使用基于滚动数组的动态规划实现，先便利物品在遍历背包，背包从后向前遍历。此处主要是递推公式存在区别 <code>dp[j]=dp[j]+dp[j-nums[i]]</code> 此处的含义在于：包含的方案有在第 <code>i</code> 次迭代时，不选择 <code>nums[i]</code> 的方案 <code>dp[j]</code> 和选择 <code>nums[i]</code> 的方案 <code>dp[j-nums[i]]</code></p><h2 id="LeetCode-474-一和零"><a href="#LeetCode-474-一和零" class="headerlink" title="LeetCode 474 一和零"></a>LeetCode 474 一和零</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中最多有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集 。</p><p>此处也是一个0/1背包问题，但是将背包的容量转变为了2维，此处每一个物品的价值都为1，那么创建一个二维数组，基于滚动数组的方式实现。那么依旧是在第 <code>k</code> 次迭代中，在元素 <code>0-k</code> 中进行选择。递推公式 <code>dp[i][j]=max(dp[i][j],dp[i-k0][j-k1]+1)</code> 也就是在第 <code>k</code> 迭代中，比较选取元素 <code>strs[k]</code> 或者不选择，哪一个能够获得最大长度。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/0-1%E8%83%8C%E5%8C%85/">0/1背包</category>
      
      
      <comments>http://marksblog.cn/posts/39479a98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-377-组合总和Ⅳ</title>
      <link>http://marksblog.cn/posts/34469175/</link>
      <guid>http://marksblog.cn/posts/34469175/</guid>
      <pubDate>Sun, 28 May 2023 09:20:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处就是一个完全背包问题，但是背包的最优化问题是最多的方案数。并且在题中指出了，顺序不同的序列将会被视为不同的组合，也就是此处元素的选择上是有序的。那么采取滚动数组的方式来实现，需要先遍历背包，再遍历元素，因为只有这样才能保证选取上的有序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[target+1]&lt;/code&gt; 表示总和为 &lt;code&gt;target&lt;/code&gt; 的元素选择方案个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在 &lt;code&gt;j&lt;/code&gt; 次迭代中，从元素 &lt;code&gt;0-n&lt;/code&gt; 中进行选择，那么相较于前面的方案，主要是背包容量增大。那么 &lt;code&gt;dp[j]=dp[j]+dp[j-nums[i]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始时，装满 &lt;code&gt;dp[0]&lt;/code&gt; 的方案有一种，那么 &lt;code&gt;dp[0]=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处是先遍历背包再遍历物品，那么先从前向后遍历背包再从前向后遍历物品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=&amp;#123;1,2,3&amp;#125; , target=4&lt;/code&gt; 动态规划的过程为:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={1,0,0,0,0}&lt;br&gt;    dp={1,1,0,0,0}&lt;br&gt;    dp={1,1,2,0,0}&lt;br&gt;    dp={1,1,2,4,0}&lt;br&gt;    dp={1,1,2,4,7}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-377-组合总和Ⅳ"><a href="#LeetCode-377-组合总和Ⅳ" class="headerlink" title="LeetCode 377 组合总和Ⅳ"></a>LeetCode 377 组合总和Ⅳ</h1><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和 Ⅳ</a></p><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>此处 <code>nums</code> 中的元素可以使用无限次。</p><p>示例：</p><blockquote><p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处就是一个完全背包问题，但是背包的最优化问题是最多的方案数。并且在题中指出了，顺序不同的序列将会被视为不同的组合，也就是此处元素的选择上是有序的。那么采取滚动数组的方式来实现，需要先遍历背包，再遍历元素，因为只有这样才能保证选取上的有序。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[target+1]</code> 表示总和为 <code>target</code> 的元素选择方案个数。</p></li><li><p>动态规划数组的推导：在 <code>j</code> 次迭代中，从元素 <code>0-n</code> 中进行选择，那么相较于前面的方案，主要是背包容量增大。那么 <code>dp[j]=dp[j]+dp[j-nums[i]]</code></p></li><li><p>动态规划数组的初始化：在初始时，装满 <code>dp[0]</code> 的方案有一种，那么 <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：此处是先遍历背包再遍历物品，那么先从前向后遍历背包再从前向后遍历物品。</p></li><li><p>举例验证：对于 <code>nums=&#123;1,2,3&#125; , target=4</code> 动态规划的过程为:</p></li></ol><blockquote><p>  dp={1,0,0,0,0}<br>    dp={1,1,0,0,0}<br>    dp={1,1,2,0,0}<br>    dp={1,1,2,4,0}<br>    dp={1,1,2,4,7}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i] &amp;&amp; dp[j]&lt;INT_MAX-dp[j-nums[i]]) dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于本题的测试用例，LeetCode官方给定的测试用例存在一定问题，会有整数溢出的问题，因此需要加上： <code>dp[j]&lt;INT_MAX-dp[j-nums[i]]</code></p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/34469175/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
