<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mark&#39;s blogs</title>
    <link>http://marksblog.cn/</link>
    
    <atom:link href="http://marksblog.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>心之所向，行之可往</description>
    <pubDate>Sun, 16 Jul 2023 12:26:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode-392-判断子序列</title>
      <link>http://marksblog.cn/posts/c7c0552e/</link>
      <guid>http://marksblog.cn/posts/c7c0552e/</guid>
      <pubDate>Sun, 16 Jul 2023 12:25:04 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;双指针法&quot;&gt;&lt;a href=&quot;#双指针法&quot; class=&quot;headerlink&quot; title=&quot;双指针法&quot;&gt;&lt;/a&gt;双指针法&lt;/h2&gt;&lt;p&gt;使用两个指针 &lt;code&gt;i,j&lt;/code&gt; 分别指向串 &lt;code&gt;s&lt;/code&gt; 和串 &lt;code&gt;t&lt;/code&gt; ，&lt;code&gt;s[i]==t[j],i++,j++&lt;/code&gt; 否则 &lt;code&gt;j++&lt;/code&gt; 当 &lt;code&gt;i=s.size()&lt;/code&gt; 时，说明是子序列，否则移动到 &lt;code&gt;j=t.size()&lt;/code&gt; 结束。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isSubsequence&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(string s, string t)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n=s.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(),m=t.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(),i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;i&amp;lt;n,j&amp;lt;m;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(s[i]==t[j]) i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i==n) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-392-判断子序列"><a href="#LeetCode-392-判断子序列" class="headerlink" title="LeetCode 392 判断子序列"></a>LeetCode 392 判断子序列</h1><p><a href="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a></p><p>给定字符串 <code>s</code> 和 <code>t</code> ，判断 <code>s</code> 是否为 <code>t</code> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>进阶：</p><p>如果有大量输入的 <code>S</code> ，称作 <code>S1, S2, ... , Sk</code> 其中 <code>k &gt;= 10亿</code> ，你需要依次检查它们是否为 <code>T</code> 的子序列。在这种情况下，你会怎样改变代码？</p><p>示例：</p><blockquote><p>输入：s = “abc”, t = “ahbgdc”<br>输出：true</p></blockquote><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>使用两个指针 <code>i,j</code> 分别指向串 <code>s</code> 和串 <code>t</code> ，<code>s[i]==t[j],i++,j++</code> 否则 <code>j++</code> 当 <code>i=s.size()</code> 时，说明是子序列，否则移动到 <code>j=t.size()</code> 结束。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>(),m=t.<span class="built_in">size</span>(),i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n,j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处使用动态规划主要是处理进阶问题，当有多个子序列 <code>s</code> 需要进行判断时，那么就需要使用一个动态规划数组做相应的记录处理。（本题并不适合使用动规进行求解，但确实可以套用相应的思想）</p><ol><li>动态规划数组的定义：定义动态规划数组 <code>dp[i][j]</code> 表示以下标 <code>i-1</code> 为结尾的字符串 <code>s</code> ，和以下标 <code>j-1</code> 为结尾的字符串 <code>t</code> ，相同子序列的长度为 <code>dp[i][j]</code> 。</li><li>动态规划数组的推导：（本质思想还是和双指针的求解方式相同）对于 <code>s[i-1]==t[j-1]</code> 说明此时相同子序列的长度可以加一， <code>dp[i][j]=dp[i-1][j-1]+1</code> 。当 <code>s[i-1]!=t[j-1]</code> 时，子序列的长度不能增加，那么 <code>dp[i][j] = dp[i][j-1]</code></li><li>动态规划数组的初始化：将第一行第一列初始化为0即可，因为初始时不存在元素。</li><li>动态规划数组的遍历顺序：逐行遍历，从前向后</li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/c7c0552e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-53-最大子序和</title>
      <link>http://marksblog.cn/posts/f8e7c5a5/</link>
      <guid>http://marksblog.cn/posts/f8e7c5a5/</guid>
      <pubDate>Tue, 11 Jul 2023 15:04:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处寻找的是连续的子序列，要求子序列的和能够最大。重点依旧是动态规划数组的定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义动态规划数组 &lt;code&gt;dp[n+1]&lt;/code&gt; ，其中 &lt;code&gt;dp[i]&lt;/code&gt; 表示以 &lt;code&gt;nums[i-1]&lt;/code&gt; 结尾的子序列的最大和。&lt;/li&gt;
&lt;li&gt;动态规划数组的推导：对于 &lt;code&gt;dp[i]&lt;/code&gt; ，推导公式为 &lt;code&gt;dp[i]=max(nums[i-1],nums[i-1]+dp[i-1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 不存在序列，初始化为0即可&lt;/li&gt;
&lt;li&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/li&gt;
&lt;li&gt;举例验证：对于 &lt;code&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/code&gt; 对应的动态规划数组输出为 &lt;code&gt;dp=-2,1,-2,4,3,5,6,1,5&lt;/code&gt; ，结果为6，验证正确。&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53 最大子序和"></a>LeetCode 53 最大子序和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/">53.最大子序和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p>示例 1：</p><blockquote><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处寻找的是连续的子序列，要求子序列的和能够最大。重点依旧是动态规划数组的定义。</p><ol><li>动态规划数组的定义：定义动态规划数组 <code>dp[n+1]</code> ，其中 <code>dp[i]</code> 表示以 <code>nums[i-1]</code> 结尾的子序列的最大和。</li><li>动态规划数组的推导：对于 <code>dp[i]</code> ，推导公式为 <code>dp[i]=max(nums[i-1],nums[i-1]+dp[i-1])</code></li><li>动态规划数组的初始化：对于 <code>dp[0]</code> 不存在序列，初始化为0即可</li><li>动态规划数组的遍历顺序：从前向后遍历</li><li>举例验证：对于 <code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code> 对应的动态规划数组输出为 <code>dp=-2,1,-2,4,3,5,6,1,5</code> ，结果为6，验证正确。</li></ol><p>代码实现：由于只使用到了前一个状态，基于滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[i<span class="number">-1</span>],dp[<span class="number">0</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>贪心的基本思想为：从当前数值 <code>nums[i]</code> 开始，不断进行元素的合并，将两个元素求和，合并为一个新得元素。再使用新的元素向后累加，若合并后的元素值小于0，那么对总体求和而言，这个首元素是负贡献的，将其舍弃，转而选取新的非负首元素，一定能够使得总的序列和更大。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=INT_MIN;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            res=<span class="built_in">max</span>(res,sum);</span><br><span class="line">            sum=sum&lt;<span class="number">0</span>?<span class="number">0</span>:sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/f8e7c5a5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-1143-最长公共子序列</title>
      <link>http://marksblog.cn/posts/f4069d5b/</link>
      <guid>http://marksblog.cn/posts/f4069d5b/</guid>
      <pubDate>Thu, 06 Jul 2023 11:40:51 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题也是一个求解最长公共子序列的问题，但是不同于&lt;a href=&quot;https://leetcode.cn/problems/maximum-length-of-repeated-subarray/&quot;&gt;718.最长重复子数组&lt;/a&gt;，在本题中的子序列是不连续的，那么使用动态规划进行求解，就需要改变动态规划数组的定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[text1.size()+1][text2.size()+1]&lt;/code&gt; ，其中 &lt;code&gt;dp[i][j]&lt;/code&gt; 表示在 &lt;code&gt;text1[i-1]&lt;/code&gt; 和 &lt;code&gt;text2[j-1]&lt;/code&gt; 前的最长子序列的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：对于 &lt;code&gt;dp[i][j]&lt;/code&gt; ，那么首先需要判断 &lt;code&gt;text1[i-1]==text2[j-1]&lt;/code&gt; ，不相等 &lt;code&gt;dp[i][j]=max(dp[i-1][j],dp[i][j-1])&lt;/code&gt; （也就是等于两个更短序列的最长的公共子序列的长度，更短的方式有两种，分别是缺少 &lt;code&gt;text1[i-2]&lt;/code&gt; 和 &lt;code&gt;text2[j-2]&lt;/code&gt; ），若是相等， &lt;code&gt;dp[i][j]=dp[i-1][j-1]+1&lt;/code&gt; ，相等则是在 &lt;code&gt;text1[i-2]&lt;/code&gt; 和 &lt;code&gt;text2[j-2]&lt;/code&gt; 的基础上在增加一个长度值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在初始时只需要全部初始化为0即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历：逐行遍历，在行内采取从前向后的遍历方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;text1 = &amp;quot;abcde&amp;quot;, text2 = &amp;quot;ace&amp;quot;&lt;/code&gt; 对应的动态规划数组为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;0,0,0,0,&lt;br&gt;0,1,1,1,&lt;br&gt;0,1,1,1,&lt;br&gt;0,1,2,2,&lt;br&gt;0,1,2,2,&lt;br&gt;0,1,2,3,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-1143-最长公共子序列"><a href="#LeetCode-1143-最长公共子序列" class="headerlink" title="LeetCode 1143 最长公共子序列"></a>LeetCode 1143 最长公共子序列</h1><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code> ，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例：</p><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题也是一个求解最长公共子序列的问题，但是不同于<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a>，在本题中的子序列是不连续的，那么使用动态规划进行求解，就需要改变动态规划数组的定义。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[text1.size()+1][text2.size()+1]</code> ，其中 <code>dp[i][j]</code> 表示在 <code>text1[i-1]</code> 和 <code>text2[j-1]</code> 前的最长子序列的长度</p></li><li><p>动态规划数组的推导：对于 <code>dp[i][j]</code> ，那么首先需要判断 <code>text1[i-1]==text2[j-1]</code> ，不相等 <code>dp[i][j]=max(dp[i-1][j],dp[i][j-1])</code> （也就是等于两个更短序列的最长的公共子序列的长度，更短的方式有两种，分别是缺少 <code>text1[i-2]</code> 和 <code>text2[j-2]</code> ），若是相等， <code>dp[i][j]=dp[i-1][j-1]+1</code> ，相等则是在 <code>text1[i-2]</code> 和 <code>text2[j-2]</code> 的基础上在增加一个长度值。</p></li><li><p>动态规划数组的初始化：在初始时只需要全部初始化为0即可。</p></li><li><p>动态规划数组的遍历：逐行遍历，在行内采取从前向后的遍历方式。</p></li><li><p>举例验证：对于 <code>text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</code> 对应的动态规划数组为：</p></li></ol><blockquote><p>0,0,0,0,<br>0,1,1,1,<br>0,1,1,1,<br>0,1,2,2,<br>0,1,2,2,<br>0,1,2,3,</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=text1.<span class="built_in">size</span>()+<span class="number">1</span>,m=text2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/f4069d5b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-718-最长重复子数组</title>
      <link>http://marksblog.cn/posts/2417182a/</link>
      <guid>http://marksblog.cn/posts/2417182a/</guid>
      <pubDate>Thu, 06 Jul 2023 11:36:41 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本质上就是在两个序列中，寻找两个最长的公共子序列（此处的公共子序列是连续的）。使用动态规划求解，重点依旧是动态规划数组的定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[nums1.size()][nums2.size()]&lt;/code&gt; 其中 &lt;code&gt;dp[i][j]&lt;/code&gt; 表示以 &lt;code&gt;nums1[i]&lt;/code&gt; 和 &lt;code&gt;nums2[j]&lt;/code&gt; 结尾的最长公共子序列的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：对于 &lt;code&gt;dp[i][j]&lt;/code&gt; ，若是 &lt;code&gt;nums1[i]==nums2[j]&lt;/code&gt; 那么 &lt;code&gt;dp[i][j]=dp[i-1][j-1]+1&lt;/code&gt; ，否则 &lt;code&gt;dp[i][j]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：此处的初始化主要是针对于第一行和第一列进行， &lt;code&gt;i=0&lt;/code&gt; 时 &lt;code&gt;dp[i][j]=1 if nums1[0]==nums2[j] else =0&lt;/code&gt; ， &lt;code&gt;j=0&lt;/code&gt; 时 &lt;code&gt;dp[i][j]=1 if nums1[i]==nums2[0] else =0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后，逐行进行遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-718-最长重复子数组"><a href="#LeetCode-718-最长重复子数组" class="headerlink" title="LeetCode 718 最长重复子数组"></a>LeetCode 718 最长重复子数组</h1><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p><p>示例：</p><blockquote><p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本质上就是在两个序列中，寻找两个最长的公共子序列（此处的公共子序列是连续的）。使用动态规划求解，重点依旧是动态规划数组的定义。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[nums1.size()][nums2.size()]</code> 其中 <code>dp[i][j]</code> 表示以 <code>nums1[i]</code> 和 <code>nums2[j]</code> 结尾的最长公共子序列的长度。</p></li><li><p>动态规划数组的推导：对于 <code>dp[i][j]</code> ，若是 <code>nums1[i]==nums2[j]</code> 那么 <code>dp[i][j]=dp[i-1][j-1]+1</code> ，否则 <code>dp[i][j]=0</code></p></li><li><p>动态规划数组的初始化：此处的初始化主要是针对于第一行和第一列进行， <code>i=0</code> 时 <code>dp[i][j]=1 if nums1[0]==nums2[j] else =0</code> ， <code>j=0</code> 时 <code>dp[i][j]=1 if nums1[i]==nums2[0] else =0</code></p></li><li><p>动态规划数组的遍历顺序：从前向后，逐行进行遍历。</p></li><li><p>举例验证：</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums1.<span class="built_in">size</span>(),m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(nums1[<span class="number">0</span>]==nums2[j])&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">                res=<span class="built_in">max</span>(res,dp[<span class="number">0</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]==nums2[<span class="number">0</span>])&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                res=<span class="built_in">max</span>(res,dp[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]==nums2[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                        res=<span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间复杂度优化：在计算 <code>dp[i][j]</code> 时，实际上只需要使用到 <code>dp[i-1][j-1]</code> ，可以基于滚动数组实现。</p><ol><li><p>动态规划数组的定义：定义动态规划数组 <code>dp[nums2.size()]</code> ，在初始时 <code>dp[j]</code> 表示以 <code>nums1[0]</code> 和 <code>nums2[j]</code> 结尾公共子序列的长度。在 <code>i</code> 次迭代时， <code>dp[j]</code> 表示以 <code>nums1[i]</code> 和 <code>nums2[j]</code> 结尾公共子序列的长度。</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代时，判断 <code>nums1[i]==nums2[j]</code> 成立则 <code>dp[j]=dp[j-1]+1</code> 否则 <code>dp[j]=0</code></p></li><li><p>动态规划数组的初始化：只需要初始化一行， <code>i=0</code> 时，<code>nums1[0]==nums2[j]</code> 成立则 <code>dp[j]=1</code> 否则 <code>dp[j]=0</code></p></li><li><p>动态规划数组的遍历顺序：逐行遍历，在行内从后向前遍历。</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums1.<span class="built_in">size</span>(),m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(nums1[<span class="number">0</span>]==nums2[j])&#123;</span><br><span class="line">                dp[j]=<span class="number">1</span>;</span><br><span class="line">                res=<span class="built_in">max</span>(res,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">                    dp[j]=dp[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    res=<span class="built_in">max</span>(res,dp[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>]=nums1[i]==nums2[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改动态规划数组的定义：将 <code>dp[i][j]</code> 表示为，以 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 结尾的最长子序列长度，数组的长度为 <code>dp[nums1.size()+1][nums2.size()+1]</code> 那么从 <code>i=1,j=1</code> 开始遍历，无序对数组进行初始化。（相同的，在滚动数组中也可以使用这样的定义）</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (nums1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;(B.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>(); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[j] = <span class="number">0</span>; <span class="comment">// 注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) result = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/2417182a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-674-最长连续递增序列</title>
      <link>http://marksblog.cn/posts/2dc2c415/</link>
      <guid>http://marksblog.cn/posts/2dc2c415/</guid>
      <pubDate>Mon, 03 Jul 2023 08:38:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;贪心实现&quot;&gt;&lt;a href=&quot;#贪心实现&quot; class=&quot;headerlink&quot; title=&quot;贪心实现&quot;&gt;&lt;/a&gt;贪心实现&lt;/h2&gt;&lt;p&gt;基于贪心实现，使用双指针的方式，只需要对数组进行一次遍历。&lt;/p&gt;
&lt;p&gt;定义指针 &lt;code&gt;i&lt;/code&gt; 直线当前连续递增子序列的第一个元素，指针 &lt;code&gt;j&lt;/code&gt; 指向当前递增子序列的最后一个元素。初始时 &lt;code&gt;i==j&lt;/code&gt; ，指针 &lt;code&gt;j&lt;/code&gt; 后移一位，若是 &lt;code&gt;nums[j]&amp;gt;nums[j+1]&lt;/code&gt; 那么 &lt;code&gt;j++&lt;/code&gt; ，否则 &lt;code&gt;len=j-i,res=max(res,len)&lt;/code&gt; ，然后 &lt;code&gt;i=j&lt;/code&gt; 继续循环。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-674-最长连续递增序列"><a href="#LeetCode-674-最长连续递增序列" class="headerlink" title="LeetCode 674 最长连续递增序列"></a>LeetCode 674 最长连续递增序列</h1><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增序列</a></p><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r（l &lt; r）</code> 确定，如果对于每个 <code>l &lt;= i &lt; r</code> ，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p>示例：</p><blockquote><p>输入：nums = [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题相较于<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a>中，要求序列是连续的，那么对于动态规划数组的定义就需要做出相应的改变。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示以元素 <code>nums[i]</code> 结尾的最长的连续子序列的长度。</p></li><li><p>动态规划数组的推导：对于 <code>dp[i]</code> 判断 <code>nums[i]&gt;nums[i-1]</code> ，成立则 <code>dp[i]=dp[i-1]+1</code> 否则 <code>dp[i]=1</code></p></li><li><p>动态规划数组的初始化：对于第一个元素 <code>nums[0]</code> 最长的连续序列的长度必然为1，那么 <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：从前先后遍历</p></li><li><p>举例验证：对于 <code>nums = [1,3,5,4,7]</code> 动态规划数组的值为：</p></li></ol><blockquote><p>dp=[1,2,3,1,2]</p></blockquote><p>代码实现：在推导时只需要使用前一个元素的值，使用滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])</span><br><span class="line">                dp[<span class="number">1</span>]=dp[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>基于贪心实现，使用双指针的方式，只需要对数组进行一次遍历。</p><p>定义指针 <code>i</code> 直线当前连续递增子序列的第一个元素，指针 <code>j</code> 指向当前递增子序列的最后一个元素。初始时 <code>i==j</code> ，指针 <code>j</code> 后移一位，若是 <code>nums[j]&gt;nums[j+1]</code> 那么 <code>j++</code> ，否则 <code>len=j-i,res=max(res,len)</code> ，然后 <code>i=j</code> 继续循环。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,j-i);</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,j-i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      <category domain="http://marksblog.cn/tags/%E8%B4%AA%E5%BF%83/">贪心</category>
      
      
      <comments>http://marksblog.cn/posts/2dc2c415/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-300-最长递增子序列</title>
      <link>http://marksblog.cn/posts/92bc8f5b/</link>
      <guid>http://marksblog.cn/posts/92bc8f5b/</guid>
      <pubDate>Mon, 03 Jul 2023 08:38:19 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处子序列是不连续的。本题的重点依旧是动态规划数组的定义：也就是如何从i推导到i+1。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i]&lt;/code&gt; 表示 &lt;code&gt;i&lt;/code&gt; 之前包括 &lt;code&gt;i&lt;/code&gt; 的以 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的最长递增子序列的长度。本题的重点应该就是关注于递增序列的结尾元素，因此要让递增序列继续增长，那么就需要和序列末尾的元素进行比较，因此将动态规划数组做此定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：那么 &lt;code&gt;dp[i+1]&lt;/code&gt; 则表示，在 &lt;code&gt;i+1&lt;/code&gt; 之前包括 &lt;code&gt;i+1&lt;/code&gt; 的以 &lt;code&gt;nums[i+1]&lt;/code&gt; 结尾的最长递增子序列的长度，那么推导为：&lt;code&gt;dp[i+1]=max(dp[j])+1&lt;/code&gt; 其中 &lt;code&gt;j=0...i&lt;/code&gt; 并且要求 &lt;code&gt;nums[j]&amp;lt;nums[i+1]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：&lt;code&gt;dp[0]&lt;/code&gt; 只包含一个元素，最长的递增子序列长度为1， &lt;code&gt;dp[0]=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：输入 &lt;code&gt;nums=[10,9,2,5,3,7,101,18]&lt;/code&gt; 动态规划数组的变化过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp=[1,1,0,0,0,0,0,0]&lt;br&gt;dp=[1,1,1,0,0,0,0,0]&lt;br&gt;dp=[1,1,1,2,0,0,0,0]&lt;br&gt;dp=[1,1,1,2,2,0,0,0]&lt;br&gt;dp=[1,1,1,2,2,3,0,0]&lt;br&gt;dp=[1,1,1,2,2,3,4,0]&lt;br&gt;dp=[1,1,1,2,2,3,4,4]&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-300-最长递增子序列"><a href="#LeetCode-300-最长递增子序列" class="headerlink" title="LeetCode 300 最长递增子序列"></a>LeetCode 300 最长递增子序列</h1><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处子序列是不连续的。本题的重点依旧是动态规划数组的定义：也就是如何从i推导到i+1。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示 <code>i</code> 之前包括 <code>i</code> 的以 <code>nums[i]</code> 结尾的最长递增子序列的长度。本题的重点应该就是关注于递增序列的结尾元素，因此要让递增序列继续增长，那么就需要和序列末尾的元素进行比较，因此将动态规划数组做此定义。</p></li><li><p>动态规划数组的推导：那么 <code>dp[i+1]</code> 则表示，在 <code>i+1</code> 之前包括 <code>i+1</code> 的以 <code>nums[i+1]</code> 结尾的最长递增子序列的长度，那么推导为：<code>dp[i+1]=max(dp[j])+1</code> 其中 <code>j=0...i</code> 并且要求 <code>nums[j]&lt;nums[i+1]</code></p></li><li><p>动态规划数组的初始化：<code>dp[0]</code> 只包含一个元素，最长的递增子序列长度为1， <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li><li><p>举例验证：输入 <code>nums=[10,9,2,5,3,7,101,18]</code> 动态规划数组的变化过程为：</p></li></ol><blockquote><p>dp=[1,1,0,0,0,0,0,0]<br>dp=[1,1,1,0,0,0,0,0]<br>dp=[1,1,1,2,0,0,0,0]<br>dp=[1,1,1,2,2,0,0,0]<br>dp=[1,1,1,2,2,3,0,0]<br>dp=[1,1,1,2,2,3,4,0]<br>dp=[1,1,1,2,2,3,4,4]</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    maxLen=<span class="built_in">max</span>(maxLen,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=maxLen+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/92bc8f5b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>股票买卖问题总结</title>
      <link>http://marksblog.cn/posts/febad6b5/</link>
      <guid>http://marksblog.cn/posts/febad6b5/</guid>
      <pubDate>Fri, 30 Jun 2023 12:10:37 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;股票买卖问题总结&quot;&gt;&lt;a href=&quot;#股票买卖问题总结&quot; class=&quot;headerlink&quot; title=&quot;股票买卖问题总结&quot;&gt;&lt;/a&gt;股票买卖问题总结&lt;/h1&gt;&lt;p&gt;问题的描述都为：给定一支股票的价格变动数组，根据相应的价格变动数组买卖股票，要求能够获得最大的利润。&lt;/p&gt;
&lt;p&gt;条件上的改变：股票只能交易一次，股票可以交易任意次，股票可以交易常数次，股票可以交易k次，股票在卖出后的一天冷冻期不能交易，股票交易需要收取手续费。&lt;/p&gt;
&lt;p&gt;基本的求解方式为：动态规划和贪心&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="股票买卖问题总结"><a href="#股票买卖问题总结" class="headerlink" title="股票买卖问题总结"></a>股票买卖问题总结</h1><p>问题的描述都为：给定一支股票的价格变动数组，根据相应的价格变动数组买卖股票，要求能够获得最大的利润。</p><p>条件上的改变：股票只能交易一次，股票可以交易任意次，股票可以交易常数次，股票可以交易k次，股票在卖出后的一天冷冻期不能交易，股票交易需要收取手续费。</p><p>基本的求解方式为：动态规划和贪心</p><h2 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121 买卖股票的最佳时机"></a>LeetCode 121 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>本题中智能对股票进行一次买卖，要求解最大的利润，存在两种方法。</p><ol><li><p>基于动态规划实现：重点依旧是动态规划数组的定义，依旧是定义为二维的动态规划数组 <code>dp[i][0]</code> 表示持有股票的最大现金数， <code>dp[i][1]</code> 表示不持有股票的最大现金数，但是限制了交易次数为1次。相较于不限次数的交易方式区别在于动态规划数组的推导。推导过程为： <code>dp[i][0]=max(dp[i-1][0],-prices[i])</code> 由于只能买入一次，在 <code>i</code> 天想要持有股票只能在前面买了，或者前面没买在 <code>prices[i]</code> 时买入。 <code>dp[i][1]=max(dp[i-1][0]+prices[i],dp[i-1][1])</code> </p></li><li><p>贪心实现：从前向后遍历，不断寻找相应的最小值，最小值就是买入那天的价格，在最小值后面能够使得利润最大的值就是卖出那天的价格。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buy=prices[<span class="number">0</span>],result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    buy=<span class="built_in">min</span>(buy,prices[i]);</span><br><span class="line">    result=<span class="built_in">max</span>(result,prices[i]-buy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者另外一种动态规划数组的定义： <code>dp[i]</code> 表示在第 <code>i</code> 天买入能够获得最大利润，也就是考虑到卖出的那一天一定是买入股票价格后最贵的一天。</p><h2 id="LeetCode-122-买卖股票的最佳时机II"><a href="#LeetCode-122-买卖股票的最佳时机II" class="headerlink" title="LeetCode 122 买卖股票的最佳时机II"></a>LeetCode 122 买卖股票的最佳时机II</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润。</p><p>在本体中对买卖的次数不做限制，依旧是动态规划和贪心两种实现方式。</p><ol><li><p>基于动态规划实现：重点依旧是动态规划数组的定义，依旧是定义为二维的动态规划数组 <code>dp[i][0]</code> 表示持有股票的最大现金数， <code>dp[i][1]</code> 表示不持有股票的最大现金数，不限制交易次数。推导过程为： <code>dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i])</code> 在 <code>i</code> 天想要持有股票可以前一天就持有，也可以前一天不持有，在 <code>prices[i]</code> 时买入。 <code>dp[i][1]=max(dp[i-1][0]+prices[i],dp[i-1][1])</code> </p></li><li><p>贪心实现：要基于贪心实现就简单很多。价格数组就是一个折线图，只需要在折线图中找到全面的增区间，将这些增区间全部相加即可。 <code>res+=max(0,prices[i]-prices[i-1]);</code></p></li></ol><h2 id="LeetCode-123-买卖股票的最佳时机III"><a href="#LeetCode-123-买卖股票的最佳时机III" class="headerlink" title="LeetCode 123 买卖股票的最佳时机III"></a>LeetCode 123 买卖股票的最佳时机III</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此处是交易次数为常数次的情形，并且需要理解的是，此处是最多交易两笔。本题只能使用动态规划进行求解，动态规划求解的重点依旧是动态规划数组的定义。</p><p>数组定义： <code>dp[i][5]</code> </p><ul><li><code>dp[i][0]</code> 表示不对股票进行任何操作所持有的最大现金数，一定是为0的</li><li><code>dp[i][1]</code> 表示第一次持有股票，所拥有的最大现金数（也就是当前是持有股票的，并且是在第一次买入后没有卖出的状态）</li><li><code>dp[i][2]</code> 表示第一次不持有股票，所拥有的最大现金数（也就是当前是不持有股票的，也就是是在第一次买入后再卖出后的状态）</li><li><code>dp[i][3]</code> 表示第二次持有股票，所拥有的最大现金数（也就是当前是持有股票的，也就是在第二次买入后没有卖出的状态）</li><li><code>dp[i][4]</code> 表示第二次不持有股票，所拥有的最大现金数（也就是当前是不持有股票的，也就是是在第二次买入后再卖出后的状态）</li></ul><p>在此基础上既可以实现动态规划数组的推导从而求解。</p><h2 id="LeetCode-188-买卖股票的最佳时机IV"><a href="#LeetCode-188-买卖股票的最佳时机IV" class="headerlink" title="LeetCode 188 买卖股票的最佳时机IV"></a>LeetCode 188 买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机IV</a></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>本题中的交易此处不再是一个常数，而是一个变量，那么也就是在上一题基础上进行了变更，只需要将动态规划数组的定义从 <code>dp[i][5]</code> 拓展到 <code>dp[i][2k+1]</code> 即可。递推公式也是相同，只需要基于循环实现即可。</p><h2 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode 309 最佳买卖股票时机含冷冻期"></a>LeetCode 309 最佳买卖股票时机含冷冻期</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></p><p>给定一个整数数组prices，其中第  <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 <code>1</code> 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>相较于前述题目，本题的变动是最大的，在加入了冷冻期的限制后，动态规划数组的定义需要改变，同时推导方式也需要改变。</p><p>动态规划数组的定义，此处每一天存在四种状态：持有股票、不持有股票并且不是冷冻期、当天卖出股票、冷冻期</p><p>在此基础上去推导：</p><ul><li><code>dp[i][0]</code> ：可能前一天持有，也可能当天买入（前一天可能是冷冻期也可能不是） <code>dp[i][0]=max(max(dp[i-1][0],dp[i-1][1]-peices[i]),dp[i-1][3]-prices[i])</code></li><li><code>dp[i][1]</code> ：前一天可能是冷冻期或者不是 <code>dp[i][1]=max(dp[i-1][1],dp[i-1][3])</code></li><li><code>dp[i][2]</code> ：前一天必然持有股票 <code>dp[i][1]=dp[i-1][0]+prices[i]</code></li><li><code>dp[i][3]</code> ：前一天必然卖出股票 <code>dp[i][3]=dp[i-1][2]</code></li></ul><h2 id="LeetCode-714-买卖股票的最佳时机含手续费"><a href="#LeetCode-714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode 714 买卖股票的最佳时机含手续费"></a>LeetCode 714 买卖股票的最佳时机含手续费</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></p><p>给定一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续</p><p>此处可以使用动态规划和贪心两种算法进行求解</p><ol><li>动态规划求解：</li></ol><p>此处使用动态规划求解，求解的方式和<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>基本相同，只需要在推导过程中，若是某天卖出在计算利润时减去手续费 <code>fee</code> 即可。</p><ol><li>使用贪心求解：</li></ol><p>此处使用贪心求解较为巧妙，将手续的收取归入股票买入阶段，假设在第一天买入股票，那么 <code>buy=prices[0]+fee</code> 就是股票买入的花费，对数组进行遍历，</p><ul><li>若是出现 <code>prices[i]+fee&lt;buy</code> 那么说明在，在这一天买入股票成本更低，更新 <code>buy</code></li><li>若是出现 <code>prices[i]&gt;buy</code> 说明此时股票的价格卖出后是可以赚钱的，并且是不限制交易次数的，那么在全局最优的情况下，这部分利润一定是能够得到的，先 <code>res+=peices[i]-buy</code> 并且 <code>buy=peices[i]</code> ，不收取手续费的原因在于，并不是真的卖出后买入，在后面若是 <code>prices[i+1]&gt;buy</code> 也就是在后一天卖出可以赚更多（相同处理），若是 <code>prices[i+1]+fee&lt;buy</code> 说明在后一天买入成本更低，那么更新 <code>buy</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buy&gt;prices[i]+fee)&#123;</span><br><span class="line">        buy=prices[i]+fee;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buy&lt;prices[i])&#123;</span><br><span class="line">        res+=peices[i]-buy;</span><br><span class="line">        buy=prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/febad6b5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-714-买卖股票的最佳时机含手续费</title>
      <link>http://marksblog.cn/posts/4c381603/</link>
      <guid>http://marksblog.cn/posts/4c381603/</guid>
      <pubDate>Thu, 29 Jun 2023 12:17:18 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;依旧是对交易的次数不进行限制，但是每买卖一次都会产生相应的手续费。使用动态规划求解，重点依旧是动态规划数组的定义。本题相对于&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/&quot;&gt;122.买卖股票的最佳时机II&lt;/a&gt;改变的仅仅是卖出环节需要收取手续费，那么就需要修改递推公式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义动态规划数组 &lt;code&gt;dp[n][2]&lt;/code&gt; ，其中 &lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天持有股票所拥有的最大现金数， &lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不持有股票所拥有的最大现金数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：分别推导 &lt;code&gt;dp[i][0]&lt;/code&gt; 和 &lt;code&gt;dp[i][1]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][0]&lt;/code&gt; 的推导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有： &lt;code&gt;dp[i][0]=dp[i-1][0]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有： &lt;code&gt;dp[i][0]=dp[i-1][1]-prices[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][1]&lt;/code&gt; 的推导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有： &lt;code&gt;dp[i][1]=dp[i-1][0]+prices[i]-fee&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有： &lt;code&gt;dp[i][1]=dp[i-1][1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体的推导为：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]-prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+prices[i]-fee,dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在第一天 &lt;code&gt;dp[0][0]=-peices[0]&lt;/code&gt; 买入，不持有只需不买入 &lt;code&gt;dp[0][1]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;prices = [1, 3, 2, 8, 4, 9], fee = 2&lt;/code&gt; 动态规划数组的变化过程为：（仅展示最后一位）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp[i]&lt;br&gt;-1 0&lt;br&gt;-1 0&lt;br&gt;-1 0&lt;br&gt;-1 5&lt;br&gt;1 5&lt;br&gt;1 8&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-714-买卖股票的最佳时机含手续费"><a href="#LeetCode-714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode 714 买卖股票的最佳时机含手续费"></a>LeetCode 714 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></p><p>给定一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续</p><p>示例：</p><blockquote><p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出：8<br>解释：能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>依旧是对交易的次数不进行限制，但是每买卖一次都会产生相应的手续费。使用动态规划求解，重点依旧是动态规划数组的定义。本题相对于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>改变的仅仅是卖出环节需要收取手续费，那么就需要修改递推公式。</p><ol><li><p>动态规划数组的定义：定义动态规划数组 <code>dp[n][2]</code> ，其中 <code>dp[i][0]</code> 表示在第 <code>i</code> 天持有股票所拥有的最大现金数， <code>dp[i][1]</code> 表示在第 <code>i</code> 天不持有股票所拥有的最大现金数</p></li><li><p>动态规划数组的推导：分别推导 <code>dp[i][0]</code> 和 <code>dp[i][1]</code></p></li></ol><p>对于 <code>dp[i][0]</code> 的推导：</p><ul><li>前一天持有： <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有： <code>dp[i][0]=dp[i-1][1]-prices[i]</code></li></ul><p>对于 <code>dp[i][1]</code> 的推导：</p><ul><li>前一天持有： <code>dp[i][1]=dp[i-1][0]+prices[i]-fee</code> </li><li>前一天不持有： <code>dp[i][1]=dp[i-1][1]</code></li></ul><p>总体的推导为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]-fee,dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：在第一天 <code>dp[0][0]=-peices[0]</code> 买入，不持有只需不买入 <code>dp[0][1]=0</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li><li><p>举例验证：对于 <code>prices = [1, 3, 2, 8, 4, 9], fee = 2</code> 动态规划数组的变化过程为：（仅展示最后一位）</p></li></ol><blockquote><p>dp[i]<br>-1 0<br>-1 0<br>-1 0<br>-1 5<br>1 5<br>1 8</p></blockquote><p>代码实现：基于滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i]-fee,dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>此处要基于贪心实现，相较于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>是有区别的，在122题中，不限交易次数的同时，交易是不需要手续费的，因此可以单纯的寻找全部的单调区间相加即可。</p><p>此处要基于贪心实现：将手续费的计算转移到股票买入阶段，使用一个变量 <code>buy</code> 记录买入股票的费用，假设在第 <code>i</code> 天买入，那么 <code>buy=prices[i]+fee</code> ，从前向后遍历 <code>prices</code> 数组。</p><ul><li>当 <code>prices[i]+fee&lt;buy</code> 时，说明在当天买入股票，能够使用更少的花费，那么对 <code>buy</code> 进行更新。</li><li>当 <code>prices[i]&gt;buy</code> 时，也就是在当天卖出是能够盈利的，但是并不能保证全局最优，但是在全局最优的情形下，这一部分的利润是一定能够赚取的，因此将这一部分利润加入总利润，并且令 <code>buy=prices[i]</code> ，不加手续费的原因在于当天并不是真的卖出后买入，主要是为了更新花费，在此基础上，若是后一天 <code>prices[i+1]&gt;buy</code> 也就是说明在后面买可以赚更多，继续抽取利润，更新费用 <code>buy=prices[i+1]</code> ，若是 <code>prices[i+1]+fee&lt;buy</code> 也就是在后一天已经不能赚钱，此时就在后一天假设买入 <code>buy=prices[i+1]+fee</code> (也就是在前一天实际进行了卖出)</li></ul><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=prices[<span class="number">0</span>]+fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]+fee&lt;buy)&#123;</span><br><span class="line">                buy=prices[i]+fee;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i]&gt;buy)&#123;</span><br><span class="line">                profit+=prices[i]-buy;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/4c381603/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-309-最佳买卖股票时机含冷冻期</title>
      <link>http://marksblog.cn/posts/dafcc9d7/</link>
      <guid>http://marksblog.cn/posts/dafcc9d7/</guid>
      <pubDate>Wed, 28 Jun 2023 12:59:05 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;要使用动态规划对本题进行求解，重点依旧是动态规划数组的定义。对于股票买卖的次数是不做限制的，对于股票的状态也仅有两种状态，持有或不持有，但是对于卖出股票后，需要限制在后一天买入股票，也就是后一天是无法持有股票的。此处需要对于每一天的状态进行进一步细分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n][4]&lt;/code&gt; ，其中 &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在 &lt;code&gt;i&lt;/code&gt; 天持有股票所拥有的最大现金， &lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不持有股票并且不是冷冻期所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天卖出股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天为冷冻期所拥有的最大现金数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][0]&lt;/code&gt; 的推导：三种情形进行推导&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有的情形，在第 &lt;code&gt;i&lt;/code&gt; 天无需对股票进行操作 &lt;code&gt;dp[i][0]=dp[i-1][0]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有的情形：&lt;ul&gt;
&lt;li&gt;前一天是不持有的并且不是冷冻期： &lt;code&gt;dp[i][0]=dp[i-1][1]-prices[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天是冷冻期，在今天恰好可以买入： &lt;code&gt;dp[i][0]=dp[i-1][3]-prices[i]&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][1]&lt;/code&gt; 的推导：两种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天不持有且不是冷冻期的情形： &lt;code&gt;dp[i][1]=dp[i-1][1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前一天是冷冻期的情形： &lt;code&gt;dp[i][1]=dp[i-1][3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][2]&lt;/code&gt; 的推导：一种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有股票： &lt;code&gt;dp[i][2]=dp[i-1][0]+prices[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][3]&lt;/code&gt; 的推导：一种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天卖出股票： &lt;code&gt;dp[i][3]=dp[i-1][2]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，总体的递推代码为：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]-prices[i],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]-prices[i]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]=dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]=dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0][0]&lt;/code&gt; 在第一天买入 &lt;code&gt;dp[0][0]=-prices[0]&lt;/code&gt; ，对于 &lt;code&gt;dp[0][1]&lt;/code&gt; 是不持有的状态，那么就只需要在一开始就不买入： &lt;code&gt;dp[0][1]=0&lt;/code&gt; 对于 &lt;code&gt;dp[0][2]&lt;/code&gt; 也就是当天买入当天卖出 &lt;code&gt;dp[0][2]=0&lt;/code&gt; 不存在第一天为冷冻期的情形，那么此时的现金数就一定是0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode 309 最佳买卖股票时机含冷冻期"></a>LeetCode 309 最佳买卖股票时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></p><p>给定一个整数数组prices，其中第  <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 <code>1</code> 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入: prices = [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>要使用动态规划对本题进行求解，重点依旧是动态规划数组的定义。对于股票买卖的次数是不做限制的，对于股票的状态也仅有两种状态，持有或不持有，但是对于卖出股票后，需要限制在后一天买入股票，也就是后一天是无法持有股票的。此处需要对于每一天的状态进行进一步细分</p><ol><li>动态规划数组的定义：定义数组 <code>dp[n][4]</code> ，其中 </li></ol><ul><li><code>dp[i][0]</code> 表示在 <code>i</code> 天持有股票所拥有的最大现金， </li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天不持有股票并且不是冷冻期所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天卖出股票所拥有的最大现金数</li><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天为冷冻期所拥有的最大现金数</li></ul><ol><li>动态规划数组的推导：</li></ol><p>对于 <code>dp[i][0]</code> 的推导：三种情形进行推导</p><ul><li>前一天持有的情形，在第 <code>i</code> 天无需对股票进行操作 <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有的情形：<ul><li>前一天是不持有的并且不是冷冻期： <code>dp[i][0]=dp[i-1][1]-prices[i]</code> </li><li>前一天是冷冻期，在今天恰好可以买入： <code>dp[i][0]=dp[i-1][3]-prices[i]</code> </li></ul></li></ul><p>对于 <code>dp[i][1]</code> 的推导：两种情形</p><ul><li>前一天不持有且不是冷冻期的情形： <code>dp[i][1]=dp[i-1][1]</code></li><li>前一天是冷冻期的情形： <code>dp[i][1]=dp[i-1][3]</code></li></ul><p>对于 <code>dp[i][2]</code> 的推导：一种情形</p><ul><li>前一天持有股票： <code>dp[i][2]=dp[i-1][0]+prices[i]</code></li></ul><p>对于 <code>dp[i][3]</code> 的推导：一种情形</p><ul><li>前一天卖出股票： <code>dp[i][3]=dp[i-1][2]</code></li></ul><p>综上所述，总体的递推代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]-prices[i]));</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：对于 <code>dp[0][0]</code> 在第一天买入 <code>dp[0][0]=-prices[0]</code> ，对于 <code>dp[0][1]</code> 是不持有的状态，那么就只需要在一开始就不买入： <code>dp[0][1]=0</code> 对于 <code>dp[0][2]</code> 也就是当天买入当天卖出 <code>dp[0][2]=0</code> 不存在第一天为冷冻期的情形，那么此时的现金数就一定是0</p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li></ol><ol><li>举例验证：</li></ol><p>代码实现：使用滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">3</span>]-prices[i]));</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>]=dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>]=dp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>],dp[<span class="number">1</span>][<span class="number">3</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题的重点在于对状态的细分，不能简单划分为持有或不持有两种，需要将当天卖出进行单独划分，根本的原因在于卖出后将会有一天的冷冻期。冷冻这一天是不允许对股票进行操作的，并且也是一种不持有股票的状态，因此状态2和状态4是能够合并的。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/dafcc9d7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-188-买卖股票的最佳时机IV</title>
      <link>http://marksblog.cn/posts/73871f91/</link>
      <guid>http://marksblog.cn/posts/73871f91/</guid>
      <pubDate>Sat, 10 Jun 2023 11:59:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;相较于 &lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/&quot;&gt;123.买卖股票的最佳时机III&lt;/a&gt;，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i][2*k+1]&lt;/code&gt; ，分别表示在第 &lt;code&gt;i&lt;/code&gt; 天的 &lt;code&gt;2*k+1&lt;/code&gt; 种状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天未对股票进行任何操作所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：推导的方式依旧是是从前一天进行推导。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][4]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的初始化：对于第 &lt;code&gt;0&lt;/code&gt; 天情形，不操作股票现金为0： &lt;code&gt;dp[0][0]=0&lt;/code&gt; 。第 &lt;code&gt;2i+1&lt;/code&gt; 次持有就是在当天买入 &lt;code&gt;dp[0][2i+1]=-prices[0]&lt;/code&gt; 第 &lt;code&gt;2i&lt;/code&gt; 次持有就是在当天卖出 &lt;code&gt;dp[0][2i]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。&lt;/li&gt;
&lt;li&gt;举例验证：对于 &lt;code&gt;k = 2, prices = [2,4,1]&lt;/code&gt; ，求解的过程为：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0, 0, 0, 0, 0}&lt;br&gt;    dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0,-1, 2, 1, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-188-买卖股票的最佳时机IV"><a href="#LeetCode-188-买卖股票的最佳时机IV" class="headerlink" title="LeetCode 188 买卖股票的最佳时机IV"></a>LeetCode 188 买卖股票的最佳时机IV</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机IV</a></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>相较于 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a>，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：</p><ol><li>动态规划数组的定义：定义数组 <code>dp[i][2*k+1]</code> ，分别表示在第 <code>i</code> 天的 <code>2*k+1</code> 种状态</li></ol><ul><li><code>dp[i][0]</code> 表示在第 <code>i</code> 天未对股票进行任何操作所拥有的最大现金数</li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数</li><li>…</li></ul><ol><li>动态规划数组的推导：推导的方式依旧是是从前一天进行推导。</li></ol><ul><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])</code></li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])</code></li><li><ul><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])</code></li></ul></li><li><code>dp[i][4]</code> 表示在第 <code>i</code> 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])</code></li><li>…</li></ul><ol><li>动态规划数组的初始化：对于第 <code>0</code> 天情形，不操作股票现金为0： <code>dp[0][0]=0</code> 。第 <code>2i+1</code> 次持有就是在当天买入 <code>dp[0][2i+1]=-prices[0]</code> 第 <code>2i</code> 次持有就是在当天卖出 <code>dp[0][2i]=0</code></li><li>动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。</li><li>举例验证：对于 <code>k = 2, prices = [2,4,1]</code> ，求解的过程为：</li></ol><blockquote><p>  dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0, 0, 0, 0, 0}<br>    dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0,-1, 2, 1, 2}</p></blockquote><p>代码实现：为了优化空间复杂度，此处采取滚动数组的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;d;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]-=prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>)&#123; <span class="comment">// 奇数</span></span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j],dp[<span class="number">0</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>]+prices[i],dp[<span class="number">0</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][d<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/73871f91/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
