<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mark&#39;s blogs</title>
    <link>http://marksblog.cn/</link>
    
    <atom:link href="http://marksblog.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>心之所向，行之可往</description>
    <pubDate>Mon, 03 Jul 2023 08:40:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode-674-最长连续递增序列</title>
      <link>http://marksblog.cn/posts/2dc2c415/</link>
      <guid>http://marksblog.cn/posts/2dc2c415/</guid>
      <pubDate>Mon, 03 Jul 2023 08:38:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;贪心实现&quot;&gt;&lt;a href=&quot;#贪心实现&quot; class=&quot;headerlink&quot; title=&quot;贪心实现&quot;&gt;&lt;/a&gt;贪心实现&lt;/h2&gt;&lt;p&gt;基于贪心实现，使用双指针的方式，只需要对数组进行一次遍历。&lt;/p&gt;
&lt;p&gt;定义指针 &lt;code&gt;i&lt;/code&gt; 直线当前连续递增子序列的第一个元素，指针 &lt;code&gt;j&lt;/code&gt; 指向当前递增子序列的最后一个元素。初始时 &lt;code&gt;i==j&lt;/code&gt; ，指针 &lt;code&gt;j&lt;/code&gt; 后移一位，若是 &lt;code&gt;nums[j]&amp;gt;nums[j+1]&lt;/code&gt; 那么 &lt;code&gt;j++&lt;/code&gt; ，否则 &lt;code&gt;len=j-i,res=max(res,len)&lt;/code&gt; ，然后 &lt;code&gt;i=j&lt;/code&gt; 继续循环。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-674-最长连续递增序列"><a href="#LeetCode-674-最长连续递增序列" class="headerlink" title="LeetCode 674 最长连续递增序列"></a>LeetCode 674 最长连续递增序列</h1><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增序列</a></p><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r（l &lt; r）</code> 确定，如果对于每个 <code>l &lt;= i &lt; r</code> ，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p>示例：</p><blockquote><p>输入：nums = [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题相较于<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a>中，要求序列是连续的，那么对于动态规划数组的定义就需要做出相应的改变。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示以元素 <code>nums[i]</code> 结尾的最长的连续子序列的长度。</p></li><li><p>动态规划数组的推导：对于 <code>dp[i]</code> 判断 <code>nums[i]&gt;nums[i-1]</code> ，成立则 <code>dp[i]=dp[i-1]+1</code> 否则 <code>dp[i]=1</code></p></li><li><p>动态规划数组的初始化：对于第一个元素 <code>nums[0]</code> 最长的连续序列的长度必然为1，那么 <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：从前先后遍历</p></li><li><p>举例验证：对于 <code>nums = [1,3,5,4,7]</code> 动态规划数组的值为：</p></li></ol><blockquote><p>dp=[1,2,3,1,2]</p></blockquote><p>代码实现：在推导时只需要使用前一个元素的值，使用滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])</span><br><span class="line">                dp[<span class="number">1</span>]=dp[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>基于贪心实现，使用双指针的方式，只需要对数组进行一次遍历。</p><p>定义指针 <code>i</code> 直线当前连续递增子序列的第一个元素，指针 <code>j</code> 指向当前递增子序列的最后一个元素。初始时 <code>i==j</code> ，指针 <code>j</code> 后移一位，若是 <code>nums[j]&gt;nums[j+1]</code> 那么 <code>j++</code> ，否则 <code>len=j-i,res=max(res,len)</code> ，然后 <code>i=j</code> 继续循环。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,j-i);</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,j-i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      <category domain="http://marksblog.cn/tags/%E8%B4%AA%E5%BF%83/">贪心</category>
      
      
      <comments>http://marksblog.cn/posts/2dc2c415/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-300-最长递增子序列</title>
      <link>http://marksblog.cn/posts/92bc8f5b/</link>
      <guid>http://marksblog.cn/posts/92bc8f5b/</guid>
      <pubDate>Mon, 03 Jul 2023 08:38:19 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处子序列是不连续的。本题的重点依旧是动态规划数组的定义：也就是如何从i推导到i+1。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i]&lt;/code&gt; 表示 &lt;code&gt;i&lt;/code&gt; 之前包括 &lt;code&gt;i&lt;/code&gt; 的以 &lt;code&gt;nums[i]&lt;/code&gt; 结尾的最长递增子序列的长度。本题的重点应该就是关注于递增序列的结尾元素，因此要让递增序列继续增长，那么就需要和序列末尾的元素进行比较，因此将动态规划数组做此定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：那么 &lt;code&gt;dp[i+1]&lt;/code&gt; 则表示，在 &lt;code&gt;i+1&lt;/code&gt; 之前包括 &lt;code&gt;i+1&lt;/code&gt; 的以 &lt;code&gt;nums[i+1]&lt;/code&gt; 结尾的最长递增子序列的长度，那么推导为：&lt;code&gt;dp[i+1]=max(dp[j])+1&lt;/code&gt; 其中 &lt;code&gt;j=0...i&lt;/code&gt; 并且要求 &lt;code&gt;nums[j]&amp;lt;nums[i+1]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：&lt;code&gt;dp[0]&lt;/code&gt; 只包含一个元素，最长的递增子序列长度为1， &lt;code&gt;dp[0]=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：输入 &lt;code&gt;nums=[10,9,2,5,3,7,101,18]&lt;/code&gt; 动态规划数组的变化过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp=[1,1,0,0,0,0,0,0]&lt;br&gt;dp=[1,1,1,0,0,0,0,0]&lt;br&gt;dp=[1,1,1,2,0,0,0,0]&lt;br&gt;dp=[1,1,1,2,2,0,0,0]&lt;br&gt;dp=[1,1,1,2,2,3,0,0]&lt;br&gt;dp=[1,1,1,2,2,3,4,0]&lt;br&gt;dp=[1,1,1,2,2,3,4,4]&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-300-最长递增子序列"><a href="#LeetCode-300-最长递增子序列" class="headerlink" title="LeetCode 300 最长递增子序列"></a>LeetCode 300 最长递增子序列</h1><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处子序列是不连续的。本题的重点依旧是动态规划数组的定义：也就是如何从i推导到i+1。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示 <code>i</code> 之前包括 <code>i</code> 的以 <code>nums[i]</code> 结尾的最长递增子序列的长度。本题的重点应该就是关注于递增序列的结尾元素，因此要让递增序列继续增长，那么就需要和序列末尾的元素进行比较，因此将动态规划数组做此定义。</p></li><li><p>动态规划数组的推导：那么 <code>dp[i+1]</code> 则表示，在 <code>i+1</code> 之前包括 <code>i+1</code> 的以 <code>nums[i+1]</code> 结尾的最长递增子序列的长度，那么推导为：<code>dp[i+1]=max(dp[j])+1</code> 其中 <code>j=0...i</code> 并且要求 <code>nums[j]&lt;nums[i+1]</code></p></li><li><p>动态规划数组的初始化：<code>dp[0]</code> 只包含一个元素，最长的递增子序列长度为1， <code>dp[0]=1</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li><li><p>举例验证：输入 <code>nums=[10,9,2,5,3,7,101,18]</code> 动态规划数组的变化过程为：</p></li></ol><blockquote><p>dp=[1,1,0,0,0,0,0,0]<br>dp=[1,1,1,0,0,0,0,0]<br>dp=[1,1,1,2,0,0,0,0]<br>dp=[1,1,1,2,2,0,0,0]<br>dp=[1,1,1,2,2,3,0,0]<br>dp=[1,1,1,2,2,3,4,0]<br>dp=[1,1,1,2,2,3,4,4]</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    maxLen=<span class="built_in">max</span>(maxLen,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=maxLen+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">子序列问题</category>
      
      
      <comments>http://marksblog.cn/posts/92bc8f5b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>股票买卖问题总结</title>
      <link>http://marksblog.cn/posts/febad6b5/</link>
      <guid>http://marksblog.cn/posts/febad6b5/</guid>
      <pubDate>Fri, 30 Jun 2023 12:10:37 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;股票买卖问题总结&quot;&gt;&lt;a href=&quot;#股票买卖问题总结&quot; class=&quot;headerlink&quot; title=&quot;股票买卖问题总结&quot;&gt;&lt;/a&gt;股票买卖问题总结&lt;/h1&gt;&lt;p&gt;问题的描述都为：给定一支股票的价格变动数组，根据相应的价格变动数组买卖股票，要求能够获得最大的利润。&lt;/p&gt;
&lt;p&gt;条件上的改变：股票只能交易一次，股票可以交易任意次，股票可以交易常数次，股票可以交易k次，股票在卖出后的一天冷冻期不能交易，股票交易需要收取手续费。&lt;/p&gt;
&lt;p&gt;基本的求解方式为：动态规划和贪心&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="股票买卖问题总结"><a href="#股票买卖问题总结" class="headerlink" title="股票买卖问题总结"></a>股票买卖问题总结</h1><p>问题的描述都为：给定一支股票的价格变动数组，根据相应的价格变动数组买卖股票，要求能够获得最大的利润。</p><p>条件上的改变：股票只能交易一次，股票可以交易任意次，股票可以交易常数次，股票可以交易k次，股票在卖出后的一天冷冻期不能交易，股票交易需要收取手续费。</p><p>基本的求解方式为：动态规划和贪心</p><h2 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121 买卖股票的最佳时机"></a>LeetCode 121 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>本题中智能对股票进行一次买卖，要求解最大的利润，存在两种方法。</p><ol><li><p>基于动态规划实现：重点依旧是动态规划数组的定义，依旧是定义为二维的动态规划数组 <code>dp[i][0]</code> 表示持有股票的最大现金数， <code>dp[i][1]</code> 表示不持有股票的最大现金数，但是限制了交易次数为1次。相较于不限次数的交易方式区别在于动态规划数组的推导。推导过程为： <code>dp[i][0]=max(dp[i-1][0],-prices[i])</code> 由于只能买入一次，在 <code>i</code> 天想要持有股票只能在前面买了，或者前面没买在 <code>prices[i]</code> 时买入。 <code>dp[i][1]=max(dp[i-1][0]+prices[i],dp[i-1][1])</code> </p></li><li><p>贪心实现：从前向后遍历，不断寻找相应的最小值，最小值就是买入那天的价格，在最小值后面能够使得利润最大的值就是卖出那天的价格。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buy=prices[<span class="number">0</span>],result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    buy=<span class="built_in">min</span>(buy,prices[i]);</span><br><span class="line">    result=<span class="built_in">max</span>(result,prices[i]-buy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者另外一种动态规划数组的定义： <code>dp[i]</code> 表示在第 <code>i</code> 天买入能够获得最大利润，也就是考虑到卖出的那一天一定是买入股票价格后最贵的一天。</p><h2 id="LeetCode-122-买卖股票的最佳时机II"><a href="#LeetCode-122-买卖股票的最佳时机II" class="headerlink" title="LeetCode 122 买卖股票的最佳时机II"></a>LeetCode 122 买卖股票的最佳时机II</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润。</p><p>在本体中对买卖的次数不做限制，依旧是动态规划和贪心两种实现方式。</p><ol><li><p>基于动态规划实现：重点依旧是动态规划数组的定义，依旧是定义为二维的动态规划数组 <code>dp[i][0]</code> 表示持有股票的最大现金数， <code>dp[i][1]</code> 表示不持有股票的最大现金数，不限制交易次数。推导过程为： <code>dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i])</code> 在 <code>i</code> 天想要持有股票可以前一天就持有，也可以前一天不持有，在 <code>prices[i]</code> 时买入。 <code>dp[i][1]=max(dp[i-1][0]+prices[i],dp[i-1][1])</code> </p></li><li><p>贪心实现：要基于贪心实现就简单很多。价格数组就是一个折线图，只需要在折线图中找到全面的增区间，将这些增区间全部相加即可。 <code>res+=max(0,prices[i]-prices[i-1]);</code></p></li></ol><h2 id="LeetCode-123-买卖股票的最佳时机III"><a href="#LeetCode-123-买卖股票的最佳时机III" class="headerlink" title="LeetCode 123 买卖股票的最佳时机III"></a>LeetCode 123 买卖股票的最佳时机III</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此处是交易次数为常数次的情形，并且需要理解的是，此处是最多交易两笔。本题只能使用动态规划进行求解，动态规划求解的重点依旧是动态规划数组的定义。</p><p>数组定义： <code>dp[i][5]</code> </p><ul><li><code>dp[i][0]</code> 表示不对股票进行任何操作所持有的最大现金数，一定是为0的</li><li><code>dp[i][1]</code> 表示第一次持有股票，所拥有的最大现金数（也就是当前是持有股票的，并且是在第一次买入后没有卖出的状态）</li><li><code>dp[i][2]</code> 表示第一次不持有股票，所拥有的最大现金数（也就是当前是不持有股票的，也就是是在第一次买入后再卖出后的状态）</li><li><code>dp[i][3]</code> 表示第二次持有股票，所拥有的最大现金数（也就是当前是持有股票的，也就是在第二次买入后没有卖出的状态）</li><li><code>dp[i][4]</code> 表示第二次不持有股票，所拥有的最大现金数（也就是当前是不持有股票的，也就是是在第二次买入后再卖出后的状态）</li></ul><p>在此基础上既可以实现动态规划数组的推导从而求解。</p><h2 id="LeetCode-188-买卖股票的最佳时机IV"><a href="#LeetCode-188-买卖股票的最佳时机IV" class="headerlink" title="LeetCode 188 买卖股票的最佳时机IV"></a>LeetCode 188 买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机IV</a></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>本题中的交易此处不再是一个常数，而是一个变量，那么也就是在上一题基础上进行了变更，只需要将动态规划数组的定义从 <code>dp[i][5]</code> 拓展到 <code>dp[i][2k+1]</code> 即可。递推公式也是相同，只需要基于循环实现即可。</p><h2 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode 309 最佳买卖股票时机含冷冻期"></a>LeetCode 309 最佳买卖股票时机含冷冻期</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></p><p>给定一个整数数组prices，其中第  <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 <code>1</code> 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>相较于前述题目，本题的变动是最大的，在加入了冷冻期的限制后，动态规划数组的定义需要改变，同时推导方式也需要改变。</p><p>动态规划数组的定义，此处每一天存在四种状态：持有股票、不持有股票并且不是冷冻期、当天卖出股票、冷冻期</p><p>在此基础上去推导：</p><ul><li><code>dp[i][0]</code> ：可能前一天持有，也可能当天买入（前一天可能是冷冻期也可能不是） <code>dp[i][0]=max(max(dp[i-1][0],dp[i-1][1]-peices[i]),dp[i-1][3]-prices[i])</code></li><li><code>dp[i][1]</code> ：前一天可能是冷冻期或者不是 <code>dp[i][1]=max(dp[i-1][1],dp[i-1][3])</code></li><li><code>dp[i][2]</code> ：前一天必然持有股票 <code>dp[i][1]=dp[i-1][0]+prices[i]</code></li><li><code>dp[i][3]</code> ：前一天必然卖出股票 <code>dp[i][3]=dp[i-1][2]</code></li></ul><h2 id="LeetCode-714-买卖股票的最佳时机含手续费"><a href="#LeetCode-714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode 714 买卖股票的最佳时机含手续费"></a>LeetCode 714 买卖股票的最佳时机含手续费</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></p><p>给定一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续</p><p>此处可以使用动态规划和贪心两种算法进行求解</p><ol><li>动态规划求解：</li></ol><p>此处使用动态规划求解，求解的方式和<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>基本相同，只需要在推导过程中，若是某天卖出在计算利润时减去手续费 <code>fee</code> 即可。</p><ol><li>使用贪心求解：</li></ol><p>此处使用贪心求解较为巧妙，将手续的收取归入股票买入阶段，假设在第一天买入股票，那么 <code>buy=prices[0]+fee</code> 就是股票买入的花费，对数组进行遍历，</p><ul><li>若是出现 <code>prices[i]+fee&lt;buy</code> 那么说明在，在这一天买入股票成本更低，更新 <code>buy</code></li><li>若是出现 <code>prices[i]&gt;buy</code> 说明此时股票的价格卖出后是可以赚钱的，并且是不限制交易次数的，那么在全局最优的情况下，这部分利润一定是能够得到的，先 <code>res+=peices[i]-buy</code> 并且 <code>buy=peices[i]</code> ，不收取手续费的原因在于，并不是真的卖出后买入，在后面若是 <code>prices[i+1]&gt;buy</code> 也就是在后一天卖出可以赚更多（相同处理），若是 <code>prices[i+1]+fee&lt;buy</code> 说明在后一天买入成本更低，那么更新 <code>buy</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buy&gt;prices[i]+fee)&#123;</span><br><span class="line">        buy=prices[i]+fee;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buy&lt;prices[i])&#123;</span><br><span class="line">        res+=peices[i]-buy;</span><br><span class="line">        buy=prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/febad6b5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-714-买卖股票的最佳时机含手续费</title>
      <link>http://marksblog.cn/posts/4c381603/</link>
      <guid>http://marksblog.cn/posts/4c381603/</guid>
      <pubDate>Thu, 29 Jun 2023 12:17:18 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;依旧是对交易的次数不进行限制，但是每买卖一次都会产生相应的手续费。使用动态规划求解，重点依旧是动态规划数组的定义。本题相对于&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/&quot;&gt;122.买卖股票的最佳时机II&lt;/a&gt;改变的仅仅是卖出环节需要收取手续费，那么就需要修改递推公式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义动态规划数组 &lt;code&gt;dp[n][2]&lt;/code&gt; ，其中 &lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天持有股票所拥有的最大现金数， &lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不持有股票所拥有的最大现金数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：分别推导 &lt;code&gt;dp[i][0]&lt;/code&gt; 和 &lt;code&gt;dp[i][1]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][0]&lt;/code&gt; 的推导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有： &lt;code&gt;dp[i][0]=dp[i-1][0]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有： &lt;code&gt;dp[i][0]=dp[i-1][1]-prices[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][1]&lt;/code&gt; 的推导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有： &lt;code&gt;dp[i][1]=dp[i-1][0]+prices[i]-fee&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有： &lt;code&gt;dp[i][1]=dp[i-1][1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体的推导为：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]-prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+prices[i]-fee,dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：在第一天 &lt;code&gt;dp[0][0]=-peices[0]&lt;/code&gt; 买入，不持有只需不买入 &lt;code&gt;dp[0][1]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;prices = [1, 3, 2, 8, 4, 9], fee = 2&lt;/code&gt; 动态规划数组的变化过程为：（仅展示最后一位）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp[i]&lt;br&gt;-1 0&lt;br&gt;-1 0&lt;br&gt;-1 0&lt;br&gt;-1 5&lt;br&gt;1 5&lt;br&gt;1 8&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-714-买卖股票的最佳时机含手续费"><a href="#LeetCode-714-买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode 714 买卖股票的最佳时机含手续费"></a>LeetCode 714 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></p><p>给定一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续</p><p>示例：</p><blockquote><p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出：8<br>解释：能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>依旧是对交易的次数不进行限制，但是每买卖一次都会产生相应的手续费。使用动态规划求解，重点依旧是动态规划数组的定义。本题相对于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>改变的仅仅是卖出环节需要收取手续费，那么就需要修改递推公式。</p><ol><li><p>动态规划数组的定义：定义动态规划数组 <code>dp[n][2]</code> ，其中 <code>dp[i][0]</code> 表示在第 <code>i</code> 天持有股票所拥有的最大现金数， <code>dp[i][1]</code> 表示在第 <code>i</code> 天不持有股票所拥有的最大现金数</p></li><li><p>动态规划数组的推导：分别推导 <code>dp[i][0]</code> 和 <code>dp[i][1]</code></p></li></ol><p>对于 <code>dp[i][0]</code> 的推导：</p><ul><li>前一天持有： <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有： <code>dp[i][0]=dp[i-1][1]-prices[i]</code></li></ul><p>对于 <code>dp[i][1]</code> 的推导：</p><ul><li>前一天持有： <code>dp[i][1]=dp[i-1][0]+prices[i]-fee</code> </li><li>前一天不持有： <code>dp[i][1]=dp[i-1][1]</code></li></ul><p>总体的推导为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]-fee,dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：在第一天 <code>dp[0][0]=-peices[0]</code> 买入，不持有只需不买入 <code>dp[0][1]=0</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li><li><p>举例验证：对于 <code>prices = [1, 3, 2, 8, 4, 9], fee = 2</code> 动态规划数组的变化过程为：（仅展示最后一位）</p></li></ol><blockquote><p>dp[i]<br>-1 0<br>-1 0<br>-1 0<br>-1 5<br>1 5<br>1 8</p></blockquote><p>代码实现：基于滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i]-fee,dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>此处要基于贪心实现，相较于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a>是有区别的，在122题中，不限交易次数的同时，交易是不需要手续费的，因此可以单纯的寻找全部的单调区间相加即可。</p><p>此处要基于贪心实现：将手续费的计算转移到股票买入阶段，使用一个变量 <code>buy</code> 记录买入股票的费用，假设在第 <code>i</code> 天买入，那么 <code>buy=prices[i]+fee</code> ，从前向后遍历 <code>prices</code> 数组。</p><ul><li>当 <code>prices[i]+fee&lt;buy</code> 时，说明在当天买入股票，能够使用更少的花费，那么对 <code>buy</code> 进行更新。</li><li>当 <code>prices[i]&gt;buy</code> 时，也就是在当天卖出是能够盈利的，但是并不能保证全局最优，但是在全局最优的情形下，这一部分的利润是一定能够赚取的，因此将这一部分利润加入总利润，并且令 <code>buy=prices[i]</code> ，不加手续费的原因在于当天并不是真的卖出后买入，主要是为了更新花费，在此基础上，若是后一天 <code>prices[i+1]&gt;buy</code> 也就是说明在后面买可以赚更多，继续抽取利润，更新费用 <code>buy=prices[i+1]</code> ，若是 <code>prices[i+1]+fee&lt;buy</code> 也就是在后一天已经不能赚钱，此时就在后一天假设买入 <code>buy=prices[i+1]+fee</code> (也就是在前一天实际进行了卖出)</li></ul><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=prices[<span class="number">0</span>]+fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]+fee&lt;buy)&#123;</span><br><span class="line">                buy=prices[i]+fee;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i]&gt;buy)&#123;</span><br><span class="line">                profit+=prices[i]-buy;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/4c381603/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-309-最佳买卖股票时机含冷冻期</title>
      <link>http://marksblog.cn/posts/dafcc9d7/</link>
      <guid>http://marksblog.cn/posts/dafcc9d7/</guid>
      <pubDate>Wed, 28 Jun 2023 12:59:05 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;要使用动态规划对本题进行求解，重点依旧是动态规划数组的定义。对于股票买卖的次数是不做限制的，对于股票的状态也仅有两种状态，持有或不持有，但是对于卖出股票后，需要限制在后一天买入股票，也就是后一天是无法持有股票的。此处需要对于每一天的状态进行进一步细分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n][4]&lt;/code&gt; ，其中 &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在 &lt;code&gt;i&lt;/code&gt; 天持有股票所拥有的最大现金， &lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不持有股票并且不是冷冻期所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天卖出股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天为冷冻期所拥有的最大现金数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][0]&lt;/code&gt; 的推导：三种情形进行推导&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有的情形，在第 &lt;code&gt;i&lt;/code&gt; 天无需对股票进行操作 &lt;code&gt;dp[i][0]=dp[i-1][0]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天不持有的情形：&lt;ul&gt;
&lt;li&gt;前一天是不持有的并且不是冷冻期： &lt;code&gt;dp[i][0]=dp[i-1][1]-prices[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;前一天是冷冻期，在今天恰好可以买入： &lt;code&gt;dp[i][0]=dp[i-1][3]-prices[i]&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][1]&lt;/code&gt; 的推导：两种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天不持有且不是冷冻期的情形： &lt;code&gt;dp[i][1]=dp[i-1][1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前一天是冷冻期的情形： &lt;code&gt;dp[i][1]=dp[i-1][3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][2]&lt;/code&gt; 的推导：一种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天持有股票： &lt;code&gt;dp[i][2]=dp[i-1][0]+prices[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 &lt;code&gt;dp[i][3]&lt;/code&gt; 的推导：一种情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前一天卖出股票： &lt;code&gt;dp[i][3]=dp[i-1][2]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，总体的递推代码为：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]-prices[i],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]-prices[i]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]=dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[i][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]=dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0][0]&lt;/code&gt; 在第一天买入 &lt;code&gt;dp[0][0]=-prices[0]&lt;/code&gt; ，对于 &lt;code&gt;dp[0][1]&lt;/code&gt; 是不持有的状态，那么就只需要在一开始就不买入： &lt;code&gt;dp[0][1]=0&lt;/code&gt; 对于 &lt;code&gt;dp[0][2]&lt;/code&gt; 也就是当天买入当天卖出 &lt;code&gt;dp[0][2]=0&lt;/code&gt; 不存在第一天为冷冻期的情形，那么此时的现金数就一定是0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode 309 最佳买卖股票时机含冷冻期"></a>LeetCode 309 最佳买卖股票时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></p><p>给定一个整数数组prices，其中第  <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 <code>1</code> 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入: prices = [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>要使用动态规划对本题进行求解，重点依旧是动态规划数组的定义。对于股票买卖的次数是不做限制的，对于股票的状态也仅有两种状态，持有或不持有，但是对于卖出股票后，需要限制在后一天买入股票，也就是后一天是无法持有股票的。此处需要对于每一天的状态进行进一步细分</p><ol><li>动态规划数组的定义：定义数组 <code>dp[n][4]</code> ，其中 </li></ol><ul><li><code>dp[i][0]</code> 表示在 <code>i</code> 天持有股票所拥有的最大现金， </li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天不持有股票并且不是冷冻期所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天卖出股票所拥有的最大现金数</li><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天为冷冻期所拥有的最大现金数</li></ul><ol><li>动态规划数组的推导：</li></ol><p>对于 <code>dp[i][0]</code> 的推导：三种情形进行推导</p><ul><li>前一天持有的情形，在第 <code>i</code> 天无需对股票进行操作 <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有的情形：<ul><li>前一天是不持有的并且不是冷冻期： <code>dp[i][0]=dp[i-1][1]-prices[i]</code> </li><li>前一天是冷冻期，在今天恰好可以买入： <code>dp[i][0]=dp[i-1][3]-prices[i]</code> </li></ul></li></ul><p>对于 <code>dp[i][1]</code> 的推导：两种情形</p><ul><li>前一天不持有且不是冷冻期的情形： <code>dp[i][1]=dp[i-1][1]</code></li><li>前一天是冷冻期的情形： <code>dp[i][1]=dp[i-1][3]</code></li></ul><p>对于 <code>dp[i][2]</code> 的推导：一种情形</p><ul><li>前一天持有股票： <code>dp[i][2]=dp[i-1][0]+prices[i]</code></li></ul><p>对于 <code>dp[i][3]</code> 的推导：一种情形</p><ul><li>前一天卖出股票： <code>dp[i][3]=dp[i-1][2]</code></li></ul><p>综上所述，总体的递推代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]-prices[i]));</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：对于 <code>dp[0][0]</code> 在第一天买入 <code>dp[0][0]=-prices[0]</code> ，对于 <code>dp[0][1]</code> 是不持有的状态，那么就只需要在一开始就不买入： <code>dp[0][1]=0</code> 对于 <code>dp[0][2]</code> 也就是当天买入当天卖出 <code>dp[0][2]=0</code> 不存在第一天为冷冻期的情形，那么此时的现金数就一定是0</p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li></ol><ol><li>举例验证：</li></ol><p>代码实现：使用滚动数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">3</span>]-prices[i]));</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>]=dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>]=dp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>],dp[<span class="number">1</span>][<span class="number">3</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题的重点在于对状态的细分，不能简单划分为持有或不持有两种，需要将当天卖出进行单独划分，根本的原因在于卖出后将会有一天的冷冻期。冷冻这一天是不允许对股票进行操作的，并且也是一种不持有股票的状态，因此状态2和状态4是能够合并的。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/dafcc9d7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-188-买卖股票的最佳时机IV</title>
      <link>http://marksblog.cn/posts/73871f91/</link>
      <guid>http://marksblog.cn/posts/73871f91/</guid>
      <pubDate>Sat, 10 Jun 2023 11:59:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;相较于 &lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/&quot;&gt;123.买卖股票的最佳时机III&lt;/a&gt;，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i][2*k+1]&lt;/code&gt; ，分别表示在第 &lt;code&gt;i&lt;/code&gt; 天的 &lt;code&gt;2*k+1&lt;/code&gt; 种状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天未对股票进行任何操作所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：推导的方式依旧是是从前一天进行推导。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][4]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的初始化：对于第 &lt;code&gt;0&lt;/code&gt; 天情形，不操作股票现金为0： &lt;code&gt;dp[0][0]=0&lt;/code&gt; 。第 &lt;code&gt;2i+1&lt;/code&gt; 次持有就是在当天买入 &lt;code&gt;dp[0][2i+1]=-prices[0]&lt;/code&gt; 第 &lt;code&gt;2i&lt;/code&gt; 次持有就是在当天卖出 &lt;code&gt;dp[0][2i]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。&lt;/li&gt;
&lt;li&gt;举例验证：对于 &lt;code&gt;k = 2, prices = [2,4,1]&lt;/code&gt; ，求解的过程为：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0, 0, 0, 0, 0}&lt;br&gt;    dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0,-1, 2, 1, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-188-买卖股票的最佳时机IV"><a href="#LeetCode-188-买卖股票的最佳时机IV" class="headerlink" title="LeetCode 188 买卖股票的最佳时机IV"></a>LeetCode 188 买卖股票的最佳时机IV</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机IV</a></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>相较于 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a>，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：</p><ol><li>动态规划数组的定义：定义数组 <code>dp[i][2*k+1]</code> ，分别表示在第 <code>i</code> 天的 <code>2*k+1</code> 种状态</li></ol><ul><li><code>dp[i][0]</code> 表示在第 <code>i</code> 天未对股票进行任何操作所拥有的最大现金数</li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数</li><li>…</li></ul><ol><li>动态规划数组的推导：推导的方式依旧是是从前一天进行推导。</li></ol><ul><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])</code></li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])</code></li><li><ul><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])</code></li></ul></li><li><code>dp[i][4]</code> 表示在第 <code>i</code> 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])</code></li><li>…</li></ul><ol><li>动态规划数组的初始化：对于第 <code>0</code> 天情形，不操作股票现金为0： <code>dp[0][0]=0</code> 。第 <code>2i+1</code> 次持有就是在当天买入 <code>dp[0][2i+1]=-prices[0]</code> 第 <code>2i</code> 次持有就是在当天卖出 <code>dp[0][2i]=0</code></li><li>动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。</li><li>举例验证：对于 <code>k = 2, prices = [2,4,1]</code> ，求解的过程为：</li></ol><blockquote><p>  dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0, 0, 0, 0, 0}<br>    dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0,-1, 2, 1, 2}</p></blockquote><p>代码实现：为了优化空间复杂度，此处采取滚动数组的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;d;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]-=prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>)&#123; <span class="comment">// 奇数</span></span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j],dp[<span class="number">0</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>]+prices[i],dp[<span class="number">0</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][d<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/73871f91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-123-买卖股票的最佳时机III</title>
      <link>http://marksblog.cn/posts/bc28a03e/</link>
      <guid>http://marksblog.cn/posts/bc28a03e/</guid>
      <pubDate>Wed, 07 Jun 2023 12:29:32 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：此处不能使用贪心进行求解，贪心的思想为：在给定的价格数组中，寻找单调增区间，选取两个区间宽度最大的单调增区间，两个区间的宽度的相加就是最大利润，也可能不存在这样的两个或一个区间。但是对于数组 &lt;code&gt;[1,2,4,2,5,7,2,4,9,0]&lt;/code&gt; ，此时贪心求解的值为12，但实际的最大利润为13。&lt;/p&gt;
&lt;p&gt;基于动态规划实现：重点依旧是动态规划数组的定义和推导。（此处的定义，使用的是持有，也就是不关系具体是在那一天进行买卖，也就是关心的是在某一天是否拥有股票）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组得到定义：定义数组 &lt;code&gt;dp[n][5]&lt;/code&gt; ，那么数组的含义为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不对股票进行操作所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][4]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 天需要对5个状态进行推导。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 此处有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天买入的 &lt;code&gt;=dp[i-1][0]-prices[i]&lt;/code&gt; ，第二是在之前买入的 &lt;code&gt;=dp[i-1][1]&lt;/code&gt; ，所以 &lt;code&gt;dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 也有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天卖出的 &lt;code&gt;=dp[i-1][1]+prices[i]&lt;/code&gt; ，第二是在之前卖出的 &lt;code&gt;=dp[i-1][2]&lt;/code&gt; ， 所以 &lt;code&gt;dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 此处有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天买入的 &lt;code&gt;=dp[i-1][2]-prices[i]&lt;/code&gt; ，第二是在之前买入的 &lt;code&gt;=dp[i-1][3]&lt;/code&gt; ，所以 &lt;code&gt;dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 也有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天卖出的 &lt;code&gt;=dp[i-1][3]+prices[i]&lt;/code&gt; ，第二是在之前卖出的 &lt;code&gt;=dp[i-1][4]&lt;/code&gt; ， 所以 &lt;code&gt;dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：此处主要是对第 &lt;code&gt;0&lt;/code&gt; 天进行初始化，不操作 &lt;code&gt;dp[0][0]=0&lt;/code&gt; ，那么在第 &lt;code&gt;0&lt;/code&gt; 天第一次持有 &lt;code&gt;dp[0][1]=-prices[0]&lt;/code&gt; 在第 &lt;code&gt;0&lt;/code&gt; 天第一次不持有，本质上就是买入后当天卖出 &lt;code&gt;dp[0][2]=0&lt;/code&gt; ，那么同理第二次持有和不持有的情形，也是当天买入后，当天卖出 &lt;code&gt;dp[0][3]=-prices[0],dp[0][4]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历：从前向后遍历的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于数组 &lt;code&gt;prices = [3,3,5,0,0,3,1,4]&lt;/code&gt; ，对应的动态规划数组为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;0 ,-3 , 0 ,-3 , 0 ,&lt;br&gt;0 ,-3 , 0 ,-3 , 0 ,&lt;br&gt;0 ,-3 , 2 ,-3 , 2 ,&lt;br&gt;0 , 0 , 2 , 2 , 2 ,&lt;br&gt;0 , 0 , 2 , 2 , 2 ,&lt;br&gt;0 , 0 , 3 , 2 , 5 ,&lt;br&gt;0 , 0 , 3 , 2 , 5 ,&lt;br&gt;0 , 0 , 4 , 2 , 6 ,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-123-买卖股票的最佳时机III"><a href="#LeetCode-123-买卖股票的最佳时机III" class="headerlink" title="LeetCode 123 买卖股票的最佳时机III"></a>LeetCode 123 买卖股票的最佳时机III</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><p>对于交易的次数进行了限制，最多只能进行两次交易，也就是交易次数&lt;=2。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>注</strong>：此处不能使用贪心进行求解，贪心的思想为：在给定的价格数组中，寻找单调增区间，选取两个区间宽度最大的单调增区间，两个区间的宽度的相加就是最大利润，也可能不存在这样的两个或一个区间。但是对于数组 <code>[1,2,4,2,5,7,2,4,9,0]</code> ，此时贪心求解的值为12，但实际的最大利润为13。</p><p>基于动态规划实现：重点依旧是动态规划数组的定义和推导。（此处的定义，使用的是持有，也就是不关系具体是在那一天进行买卖，也就是关心的是在某一天是否拥有股票）</p><ol><li>动态规划数组得到定义：定义数组 <code>dp[n][5]</code> ，那么数组的含义为：</li></ol><ul><li><code>dp[i][0]</code> 表示在第 <code>i</code> 天不对股票进行操作所拥有的最大现金数</li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数</li><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天第二次持有股票所拥有的最大现金数</li><li><code>dp[i][4]</code> 表示在第 <code>i</code> 天第二次不持有股票所拥有的最大现金数</li></ul><ol><li>动态规划数组的推导：在第 <code>i</code> 天需要对5个状态进行推导。</li></ol><ul><li><code>dp[i][0]=0</code></li><li><code>dp[i][1]</code> 此处有两种情况：第一，是在第 <code>i</code> 天买入的 <code>=dp[i-1][0]-prices[i]</code> ，第二是在之前买入的 <code>=dp[i-1][1]</code> ，所以 <code>dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])</code></li><li><code>dp[i][2]</code> 也有两种情况：第一，是在第 <code>i</code> 天卖出的 <code>=dp[i-1][1]+prices[i]</code> ，第二是在之前卖出的 <code>=dp[i-1][2]</code> ， 所以 <code>dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])</code></li><li><code>dp[i][3]</code> 此处有两种情况：第一，是在第 <code>i</code> 天买入的 <code>=dp[i-1][2]-prices[i]</code> ，第二是在之前买入的 <code>=dp[i-1][3]</code> ，所以 <code>dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3])</code></li><li><code>dp[i][2]</code> 也有两种情况：第一，是在第 <code>i</code> 天卖出的 <code>=dp[i-1][3]+prices[i]</code> ，第二是在之前卖出的 <code>=dp[i-1][4]</code> ， 所以 <code>dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])</code></li></ul><ol><li><p>动态规划数组的初始化：此处主要是对第 <code>0</code> 天进行初始化，不操作 <code>dp[0][0]=0</code> ，那么在第 <code>0</code> 天第一次持有 <code>dp[0][1]=-prices[0]</code> 在第 <code>0</code> 天第一次不持有，本质上就是买入后当天卖出 <code>dp[0][2]=0</code> ，那么同理第二次持有和不持有的情形，也是当天买入后，当天卖出 <code>dp[0][3]=-prices[0],dp[0][4]=0</code></p></li><li><p>动态规划数组的遍历：从前向后遍历的方式</p></li><li><p>举例验证：对于数组 <code>prices = [3,3,5,0,0,3,1,4]</code> ，对应的动态规划数组为：</p></li></ol><blockquote><p>0 ,-3 , 0 ,-3 , 0 ,<br>0 ,-3 , 0 ,-3 , 0 ,<br>0 ,-3 , 2 ,-3 , 2 ,<br>0 , 0 , 2 , 2 , 2 ,<br>0 , 0 , 2 , 2 , 2 ,<br>0 , 0 , 3 , 2 , 5 ,<br>0 , 0 , 3 , 2 , 5 ,<br>0 , 0 , 4 , 2 , 6 ,</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">2</span>],dp[n<span class="number">-1</span>][<span class="number">4</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处也是只使用了前一天的数据，可以使用滚动数组优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">4</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">3</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">4</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>],dp[<span class="number">1</span>][<span class="number">4</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/bc28a03e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-122-买卖股票的最佳时机II</title>
      <link>http://marksblog.cn/posts/4faebc0f/</link>
      <guid>http://marksblog.cn/posts/4faebc0f/</guid>
      <pubDate>Tue, 06 Jun 2023 11:49:25 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h2&gt;&lt;p&gt;相较于&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&quot;&gt;121.买卖股票的最佳时机&lt;/a&gt;，本题的主要区别在于：考虑的不只是单次买卖股票的情形，可以对一只股票多次进行买卖，需要求解的是整体的最优化。&lt;/p&gt;
&lt;p&gt;要想实现最大的利润，那么本质上就是在序列中寻找单调区间，将序列中的全部单调增区间的区间长度相加，就是最大的利润值。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; prices)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n=prices.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; start=prices[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],last=start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(prices[i]&amp;gt;=last)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                last=prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res+=last-start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                start=prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                last=start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res+=last-start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更加高效的贪心实现：在本题中，交易的次数是不存在限制的，因此完全可以采取如下策略。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;i-1&lt;/code&gt; 只要 &lt;code&gt;prices[i]&amp;gt;prices[i-1]&lt;/code&gt; 那么就在 &lt;code&gt;i-1&lt;/code&gt; 买入，在 &lt;code&gt;i&lt;/code&gt; 天卖出，也就是赚取全部能够赚取的利润。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; prices)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n=prices.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res+=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,prices[i]-prices[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-122-买卖股票的最佳时机II"><a href="#LeetCode-122-买卖股票的最佳时机II" class="headerlink" title="LeetCode 122 买卖股票的最佳时机II"></a>LeetCode 122 买卖股票的最佳时机II</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润。</p><p>示例：</p><blockquote><p>输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。<br>     总利润为 4 + 3 = 7 。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>相较于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a>，本题的主要区别在于：考虑的不只是单次买卖股票的情形，可以对一只股票多次进行买卖，需要求解的是整体的最优化。</p><p>要想实现最大的利润，那么本质上就是在序列中寻找单调区间，将序列中的全部单调增区间的区间长度相加，就是最大的利润值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start=prices[<span class="number">0</span>],last=start;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;=last)&#123;</span><br><span class="line">                last=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=last-start;</span><br><span class="line">                start=prices[i];</span><br><span class="line">                last=start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=last-start;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更加高效的贪心实现：在本题中，交易的次数是不存在限制的，因此完全可以采取如下策略。</p><p>对于 <code>i</code> 和 <code>i-1</code> 只要 <code>prices[i]&gt;prices[i-1]</code> 那么就在 <code>i-1</code> 买入，在 <code>i</code> 天卖出，也就是赚取全部能够赚取的利润。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res+=<span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，寻找单调递增区间的操作基于暴力法也是能够实现的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处使用动态规划进行求解存在两个要点：首先是动态规划数组的定义，其次是动态规划数组的定义（本质上还是如何对问题进行划分）</p><ol><li><p>动态规划数组的定义：定义一个二维的动态规划数组 <code>dp[n][2]</code> ，其中 <code>dp[i][0]</code> 表示在第 <code>i</code> 持有股票所拥有的现金， <code>dp[i][1]</code> 表示在第 <code>i</code> <strong>天不持有股票所能获得最多的现金</strong>。关于现金的含义：在初始状态现金为0，那么在某天买入后现金是 <code>-prices[i]</code> ，只有在股票卖出后当前持有的现金才会发生改变。</p></li><li><p>动态规划数组的推导：</p></li></ol><p>对于 <code>dp[i][0]</code> 的推导：本质上还是针对于前一天的情形进行推导</p><ul><li>前一天持有的情形，在第 <code>i</code> 天无需对股票进行操作 <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有的情形， <code>dp[i][0]=dp[i-1][1]-prices[i]</code> 也就是在第 <code>i</code> 天进行了股票的买入</li></ul><p>对于 <code>dp[i][1]</code> 的推导：在前一天持有或不持有两种情形</p><ul><li>前一天持有的情形，在第 <code>i</code> 天对股票进行卖出操作 <code>dp[i][1]=dp[i-1][0]+prices[i]</code> </li><li>前一天不持有的情形， <code>dp[i][1]=dp[i-1][1]</code> 也就是在第 <code>i</code> 天不对股票进行操作</li></ul><ol><li><p>动态规划数组的初始化：对于第0天的情形，不持有股票现金为0，持有股票现金为 <code>-prices[0]</code> ，那么 <code>dp[0][0]=-prices[0],dp[0][1]=0</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为滚动数组实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/4faebc0f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-121-买卖股票的最佳时机</title>
      <link>http://marksblog.cn/posts/3f336a0e/</link>
      <guid>http://marksblog.cn/posts/3f336a0e/</guid>
      <pubDate>Mon, 05 Jun 2023 15:25:56 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 &lt;code&gt;i&lt;/code&gt; 天买入，能够获得最大利润使用 &lt;code&gt;dp[i]&lt;/code&gt; 表示，那么第 &lt;code&gt;i+1&lt;/code&gt; 天买入能够获得的最大利润使用 &lt;code&gt;dp[i+1]&lt;/code&gt; 表示，那么 &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt; ，那么使用动态规划进行求解的过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 天买入能够获得的最大利润&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导： &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 &lt;code&gt;dp[n+1]=0&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在计算 &lt;code&gt;dp[n]&lt;/code&gt; 时需要使用 &lt;code&gt;dp[n+1]&lt;/code&gt; 的信息，因此此处需要使用从后向前遍历的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;code&gt;vector&amp;lt;int&amp;gt; prices=&amp;#123;7,1,5,3,6,4&amp;#125;;&lt;/code&gt; 动态规划数组的输出为： &lt;code&gt;dp=[0,0,3,1,5,0]&lt;/code&gt; 验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121 买卖股票的最佳时机"></a>LeetCode 121 买卖股票的最佳时机</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>示例</p><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 <code>i</code> 天买入，能够获得最大利润使用 <code>dp[i]</code> 表示，那么第 <code>i+1</code> 天买入能够获得的最大利润使用 <code>dp[i+1]</code> 表示，那么 <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code> ，那么使用动态规划进行求解的过程为：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示第 <code>n</code> 天买入能够获得的最大利润</p></li><li><p>动态规划数组的推导： <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code></p></li><li><p>动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 <code>dp[n+1]=0</code> </p></li><li><p>动态规划数组的遍历顺序：在计算 <code>dp[n]</code> 时需要使用 <code>dp[n+1]</code> 的信息，因此此处需要使用从后向前遍历的方式。</p></li><li><p>对于 <code>vector&lt;int&gt; prices=&#123;7,1,5,3,6,4&#125;;</code> 动态规划数组的输出为： <code>dp=[0,0,3,1,5,0]</code> 验证正确</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>]+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处仅仅使用到了前一天的状态，那么可以基于滚动数组实现，从而减少空间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            n1=<span class="built_in">max</span>(n0+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,n1);</span><br><span class="line">            n0=n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>本质上就是在一个数组中，寻找两个点之间的最大间距，使用一个双for循环即可完成穷举。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,prices[j]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式将会超出时间限制。</p><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>最简单的思想就是，在左边找到一个最小值，在右边找到一个最大值，做减法即可得到需要求解的值。</p><p>在左边寻找最小值的过程，本质上就是在从左向右遍历的过程中记录最小值，让当前值始终与记录的最小值做减法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minp=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minp=<span class="built_in">min</span>(minp,prices[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,prices[i]-minp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/3f336a0e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-337-打家劫舍III</title>
      <link>http://marksblog.cn/posts/1aa3096f/</link>
      <guid>http://marksblog.cn/posts/1aa3096f/</guid>
      <pubDate>Mon, 05 Jun 2023 14:31:28 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;深度优先&quot;&gt;&lt;a href=&quot;#深度优先&quot; class=&quot;headerlink&quot; title=&quot;深度优先&quot;&gt;&lt;/a&gt;深度优先&lt;/h2&gt;&lt;p&gt;改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。&lt;/p&gt;
&lt;p&gt;暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;robTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 计算对于以root为根节点能够抢到的最大的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 当前节点非空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val1=root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;left) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;right) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val2=&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(val1,val2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。&lt;/p&gt;
&lt;p&gt;记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 &lt;code&gt;robTree(root-&amp;gt;left)&lt;/code&gt; 的时候就重复计算了 &lt;code&gt;(robTree(root-&amp;gt;left-&amp;gt;left)+robTree(root-&amp;gt;left-&amp;gt;right))&lt;/code&gt; ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-337-打家劫舍III"><a href="#LeetCode-337-打家劫舍III" class="headerlink" title="LeetCode 337 打家劫舍III"></a>LeetCode 337 打家劫舍III</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍III</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例：</p><p><img src="打家劫舍III.png" alt="打家劫舍III"></p><blockquote><p>  输入: root = [3,2,3,null,3,null,1]<br>    输出: 7<br>    解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p></blockquote><h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。</p><p>暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123; <span class="comment">// 计算对于以root为根节点能够抢到的最大的值</span></span><br><span class="line">        <span class="keyword">if</span>(root)&#123; <span class="comment">// 当前节点非空</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="type">int</span> val1=root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) val1+=(<span class="built_in">robTree</span>(root-&gt;left-&gt;left)+<span class="built_in">robTree</span>(root-&gt;left-&gt;right));</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) val1+=(<span class="built_in">robTree</span>(root-&gt;right-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right-&gt;right));</span><br><span class="line">            <span class="type">int</span> val2=<span class="built_in">robTree</span>(root-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(val1,val2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">robTree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。</p><p>记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 <code>robTree(root-&gt;left)</code> 的时候就重复计算了 <code>(robTree(root-&gt;left-&gt;left)+robTree(root-&gt;left-&gt;right))</code> ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode* , <span class="type">int</span>&gt; umap; <span class="comment">// 记录计算过的结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (umap[root]) <span class="keyword">return</span> umap[root]; <span class="comment">// 如果umap里已经有记录则直接返回</span></span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="type">int</span> val1 = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) val1 += <span class="built_in">rob</span>(root-&gt;left-&gt;left) + <span class="built_in">rob</span>(root-&gt;left-&gt;right); <span class="comment">// 跳过root-&gt;left</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) val1 += <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right); <span class="comment">// 跳过root-&gt;right</span></span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right); <span class="comment">// 考虑root的左右孩子</span></span><br><span class="line">        umap[root] = <span class="built_in">max</span>(val1, val2); <span class="comment">// umap记录一下结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处的动态规划实现，基本上和记忆化搜索类似。也是在递归的基础上实现。进行动态规划的基本思路依旧是：对于以 <code>root</code> 为根的子树，能够选取到的最大的节点数值总和为，max(选取当前节点+两棵子树后代的最大值，不选当前节点两棵子树的最大值之和) 。</p><p>此处需要基于动态规划实现，并且要避免重复的计算操作，那么使用一个递归函数，返回一个长度为2的数组，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p><ol><li><p>动态规划数组的定义：对于递归函数 <code>robTree(TreeNode* root)</code>，返回 <code>vector&lt;int&gt; dp(2)</code> ，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p></li><li><p>动态规划数组的推导：在当前的递归函数层中，需要计算的有两个值，其中 <code>dp[0]</code> 表示的是选取根节点能够获取到的最大值，那么左右孩子节点是一定不能够选取的 <code>dp[0]=root-&gt;val+robTree(root-&gt;left)[1]+robTree(root-&gt;right)[1]</code> ，对于<code>dp[1]</code> 表示的是不选取根节点能够获取到的最大值，此时左右孩子节点是可选可不选的，那么具体能否进行选取，取决那种方式能够获取到更大的值 <code>dp[1]=max(robTree(root-&gt;left)[0],robTree(root-&gt;left)[1])+max(robTree(root-&gt;right)[0],robTree(root-&gt;right)[1])</code></p></li><li><p>动态规划数组的初始化：对于空节点 <code>robTree(nullptr)=&#123;0,0&#125;</code></p></li><li><p>动态规划数组的遍历顺序：本质上就是DFS，并且对于根节点而言是后序遍历</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            res[<span class="number">0</span>]=root-&gt;val+val1[<span class="number">1</span>]+val2[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>]=<span class="built_in">max</span>(val1[<span class="number">0</span>],val1[<span class="number">1</span>])+<span class="built_in">max</span>(val2[<span class="number">0</span>],val2[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在动态规划的过程中，采取的是后序遍历的方式，上层节点的值是在底层节点的值完成计算后，才得到的，并且使用一个vector数组同时记录了选取根节点和不选取根节点的最优解。但是由于在递归函数的返回值中使用的是vector数组，vector数组在创建时将会预分配较大的内存空间，导致程序的开销较大，此处改用 <code>pair</code> ，将会使得LeetCode上的运行时间和内存空间大大降低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line">            res.first=root-&gt;val+val1.second+val2.second;</span><br><span class="line">            res.second=<span class="built_in">max</span>(val1.first,val1.second)+<span class="built_in">max</span>(val2.first,val2.second);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res.first,res.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/1aa3096f/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
