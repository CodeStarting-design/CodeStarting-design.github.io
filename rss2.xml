<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mark&#39;s blogs</title>
    <link>http://marksblog.cn/</link>
    
    <atom:link href="http://marksblog.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>心之所向，行之可往</description>
    <pubDate>Sat, 10 Jun 2023 12:00:18 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode-188-买卖股票的最佳时机IV</title>
      <link>http://marksblog.cn/posts/73871f91/</link>
      <guid>http://marksblog.cn/posts/73871f91/</guid>
      <pubDate>Sat, 10 Jun 2023 11:59:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;相较于 &lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/&quot;&gt;123.买卖股票的最佳时机III&lt;/a&gt;，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i][2*k+1]&lt;/code&gt; ，分别表示在第 &lt;code&gt;i&lt;/code&gt; 天的 &lt;code&gt;2*k+1&lt;/code&gt; 种状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天未对股票进行任何操作所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：推导的方式依旧是是从前一天进行推导。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： &lt;code&gt;dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][4]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： &lt;code&gt;dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的初始化：对于第 &lt;code&gt;0&lt;/code&gt; 天情形，不操作股票现金为0： &lt;code&gt;dp[0][0]=0&lt;/code&gt; 。第 &lt;code&gt;2i+1&lt;/code&gt; 次持有就是在当天买入 &lt;code&gt;dp[0][2i+1]=-prices[0]&lt;/code&gt; 第 &lt;code&gt;2i&lt;/code&gt; 次持有就是在当天卖出 &lt;code&gt;dp[0][2i]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。&lt;/li&gt;
&lt;li&gt;举例验证：对于 &lt;code&gt;k = 2, prices = [2,4,1]&lt;/code&gt; ，求解的过程为：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0, 0, 0, 0, 0}&lt;br&gt;    dp={0,-2, 0,-2, 0}&lt;br&gt;    dp={0,-2, 2,-2, 2}&lt;br&gt;    dp={0,-1, 2, 1, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-188-买卖股票的最佳时机IV"><a href="#LeetCode-188-买卖股票的最佳时机IV" class="headerlink" title="LeetCode 188 买卖股票的最佳时机IV"></a>LeetCode 188 买卖股票的最佳时机IV</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机IV</a></p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>相较于 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a>，此处对于交易的次数进行了另一种限定，交易的次数是可变的。尝试依旧采取同样的方式去定义动态规划数组：</p><ol><li>动态规划数组的定义：定义数组 <code>dp[i][2*k+1]</code> ，分别表示在第 <code>i</code> 天的 <code>2*k+1</code> 种状态</li></ol><ul><li><code>dp[i][0]</code> 表示在第 <code>i</code> 天未对股票进行任何操作所拥有的最大现金数</li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数</li><li>…</li></ul><ol><li>动态规划数组的推导：推导的方式依旧是是从前一天进行推导。</li></ol><ul><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])</code></li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])</code></li><li><ul><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天第二次持有股票所拥有的最大现金数，那么只有前一天就持有和前一天不持有两种情况： <code>dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])</code></li></ul></li><li><code>dp[i][4]</code> 表示在第 <code>i</code> 天第二次不持有股票所拥有的最大现金数，那么只有前一天持有和前一天不持有两种情况： <code>dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])</code></li><li>…</li></ul><ol><li>动态规划数组的初始化：对于第 <code>0</code> 天情形，不操作股票现金为0： <code>dp[0][0]=0</code> 。第 <code>2i+1</code> 次持有就是在当天买入 <code>dp[0][2i+1]=-prices[0]</code> 第 <code>2i</code> 次持有就是在当天卖出 <code>dp[0][2i]=0</code></li><li>动态规划数组的遍历：对于当前状态的推导需要使用前一天的数据，从前向后遍历。</li><li>举例验证：对于 <code>k = 2, prices = [2,4,1]</code> ，求解的过程为：</li></ol><blockquote><p>  dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0, 0, 0, 0, 0}<br>    dp={0,-2, 0,-2, 0}<br>    dp={0,-2, 2,-2, 2}<br>    dp={0,-1, 2, 1, 2}</p></blockquote><p>代码实现：为了优化空间复杂度，此处采取滚动数组的方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;d;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]-=prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>)&#123; <span class="comment">// 奇数</span></span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j],dp[<span class="number">0</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>]+prices[i],dp[<span class="number">0</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][d<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/73871f91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-123-买卖股票的最佳时机III</title>
      <link>http://marksblog.cn/posts/bc28a03e/</link>
      <guid>http://marksblog.cn/posts/bc28a03e/</guid>
      <pubDate>Wed, 07 Jun 2023 12:29:32 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：此处不能使用贪心进行求解，贪心的思想为：在给定的价格数组中，寻找单调增区间，选取两个区间宽度最大的单调增区间，两个区间的宽度的相加就是最大利润，也可能不存在这样的两个或一个区间。但是对于数组 &lt;code&gt;[1,2,4,2,5,7,2,4,9,0]&lt;/code&gt; ，此时贪心求解的值为12，但实际的最大利润为13。&lt;/p&gt;
&lt;p&gt;基于动态规划实现：重点依旧是动态规划数组的定义和推导。（此处的定义，使用的是持有，也就是不关系具体是在那一天进行买卖，也就是关心的是在某一天是否拥有股票）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组得到定义：定义数组 &lt;code&gt;dp[n][5]&lt;/code&gt; ，那么数组的含义为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天不对股票进行操作所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第一次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次持有股票所拥有的最大现金数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][4]&lt;/code&gt; 表示在第 &lt;code&gt;i&lt;/code&gt; 天第二次不持有股票所拥有的最大现金数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 天需要对5个状态进行推导。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dp[i][0]=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][1]&lt;/code&gt; 此处有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天买入的 &lt;code&gt;=dp[i-1][0]-prices[i]&lt;/code&gt; ，第二是在之前买入的 &lt;code&gt;=dp[i-1][1]&lt;/code&gt; ，所以 &lt;code&gt;dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 也有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天卖出的 &lt;code&gt;=dp[i-1][1]+prices[i]&lt;/code&gt; ，第二是在之前卖出的 &lt;code&gt;=dp[i-1][2]&lt;/code&gt; ， 所以 &lt;code&gt;dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][3]&lt;/code&gt; 此处有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天买入的 &lt;code&gt;=dp[i-1][2]-prices[i]&lt;/code&gt; ，第二是在之前买入的 &lt;code&gt;=dp[i-1][3]&lt;/code&gt; ，所以 &lt;code&gt;dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][2]&lt;/code&gt; 也有两种情况：第一，是在第 &lt;code&gt;i&lt;/code&gt; 天卖出的 &lt;code&gt;=dp[i-1][3]+prices[i]&lt;/code&gt; ，第二是在之前卖出的 &lt;code&gt;=dp[i-1][4]&lt;/code&gt; ， 所以 &lt;code&gt;dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：此处主要是对第 &lt;code&gt;0&lt;/code&gt; 天进行初始化，不操作 &lt;code&gt;dp[0][0]=0&lt;/code&gt; ，那么在第 &lt;code&gt;0&lt;/code&gt; 天第一次持有 &lt;code&gt;dp[0][1]=-prices[0]&lt;/code&gt; 在第 &lt;code&gt;0&lt;/code&gt; 天第一次不持有，本质上就是买入后当天卖出 &lt;code&gt;dp[0][2]=0&lt;/code&gt; ，那么同理第二次持有和不持有的情形，也是当天买入后，当天卖出 &lt;code&gt;dp[0][3]=-prices[0],dp[0][4]=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历：从前向后遍历的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于数组 &lt;code&gt;prices = [3,3,5,0,0,3,1,4]&lt;/code&gt; ，对应的动态规划数组为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;0 ,-3 , 0 ,-3 , 0 ,&lt;br&gt;0 ,-3 , 0 ,-3 , 0 ,&lt;br&gt;0 ,-3 , 2 ,-3 , 2 ,&lt;br&gt;0 , 0 , 2 , 2 , 2 ,&lt;br&gt;0 , 0 , 2 , 2 , 2 ,&lt;br&gt;0 , 0 , 3 , 2 , 5 ,&lt;br&gt;0 , 0 , 3 , 2 , 5 ,&lt;br&gt;0 , 0 , 4 , 2 , 6 ,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-123-买卖股票的最佳时机III"><a href="#LeetCode-123-买卖股票的最佳时机III" class="headerlink" title="LeetCode 123 买卖股票的最佳时机III"></a>LeetCode 123 买卖股票的最佳时机III</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机III</a></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><blockquote><p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><p>对于交易的次数进行了限制，最多只能进行两次交易，也就是交易次数&lt;=2。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>注</strong>：此处不能使用贪心进行求解，贪心的思想为：在给定的价格数组中，寻找单调增区间，选取两个区间宽度最大的单调增区间，两个区间的宽度的相加就是最大利润，也可能不存在这样的两个或一个区间。但是对于数组 <code>[1,2,4,2,5,7,2,4,9,0]</code> ，此时贪心求解的值为12，但实际的最大利润为13。</p><p>基于动态规划实现：重点依旧是动态规划数组的定义和推导。（此处的定义，使用的是持有，也就是不关系具体是在那一天进行买卖，也就是关心的是在某一天是否拥有股票）</p><ol><li>动态规划数组得到定义：定义数组 <code>dp[n][5]</code> ，那么数组的含义为：</li></ol><ul><li><code>dp[i][0]</code> 表示在第 <code>i</code> 天不对股票进行操作所拥有的最大现金数</li><li><code>dp[i][1]</code> 表示在第 <code>i</code> 天第一次持有股票所拥有的最大现金数</li><li><code>dp[i][2]</code> 表示在第 <code>i</code> 天第一次不持有股票所拥有的最大现金数</li><li><code>dp[i][3]</code> 表示在第 <code>i</code> 天第二次持有股票所拥有的最大现金数</li><li><code>dp[i][4]</code> 表示在第 <code>i</code> 天第二次不持有股票所拥有的最大现金数</li></ul><ol><li>动态规划数组的推导：在第 <code>i</code> 天需要对5个状态进行推导。</li></ol><ul><li><code>dp[i][0]=0</code></li><li><code>dp[i][1]</code> 此处有两种情况：第一，是在第 <code>i</code> 天买入的 <code>=dp[i-1][0]-prices[i]</code> ，第二是在之前买入的 <code>=dp[i-1][1]</code> ，所以 <code>dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])</code></li><li><code>dp[i][2]</code> 也有两种情况：第一，是在第 <code>i</code> 天卖出的 <code>=dp[i-1][1]+prices[i]</code> ，第二是在之前卖出的 <code>=dp[i-1][2]</code> ， 所以 <code>dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])</code></li><li><code>dp[i][3]</code> 此处有两种情况：第一，是在第 <code>i</code> 天买入的 <code>=dp[i-1][2]-prices[i]</code> ，第二是在之前买入的 <code>=dp[i-1][3]</code> ，所以 <code>dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3])</code></li><li><code>dp[i][2]</code> 也有两种情况：第一，是在第 <code>i</code> 天卖出的 <code>=dp[i-1][3]+prices[i]</code> ，第二是在之前卖出的 <code>=dp[i-1][4]</code> ， 所以 <code>dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4])</code></li></ul><ol><li><p>动态规划数组的初始化：此处主要是对第 <code>0</code> 天进行初始化，不操作 <code>dp[0][0]=0</code> ，那么在第 <code>0</code> 天第一次持有 <code>dp[0][1]=-prices[0]</code> 在第 <code>0</code> 天第一次不持有，本质上就是买入后当天卖出 <code>dp[0][2]=0</code> ，那么同理第二次持有和不持有的情形，也是当天买入后，当天卖出 <code>dp[0][3]=-prices[0],dp[0][4]=0</code></p></li><li><p>动态规划数组的遍历：从前向后遍历的方式</p></li><li><p>举例验证：对于数组 <code>prices = [3,3,5,0,0,3,1,4]</code> ，对应的动态规划数组为：</p></li></ol><blockquote><p>0 ,-3 , 0 ,-3 , 0 ,<br>0 ,-3 , 0 ,-3 , 0 ,<br>0 ,-3 , 2 ,-3 , 2 ,<br>0 , 0 , 2 , 2 , 2 ,<br>0 , 0 , 2 , 2 , 2 ,<br>0 , 0 , 3 , 2 , 5 ,<br>0 , 0 , 3 , 2 , 5 ,<br>0 , 0 , 4 , 2 , 6 ,</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">2</span>],dp[n<span class="number">-1</span>][<span class="number">4</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处也是只使用了前一天的数据，可以使用滚动数组优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>]-prices[i],dp[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">4</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">3</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">4</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>],dp[<span class="number">1</span>][<span class="number">4</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/bc28a03e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-122-买卖股票的最佳时机II</title>
      <link>http://marksblog.cn/posts/4faebc0f/</link>
      <guid>http://marksblog.cn/posts/4faebc0f/</guid>
      <pubDate>Tue, 06 Jun 2023 11:49:25 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h2&gt;&lt;p&gt;相较于&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&quot;&gt;121.买卖股票的最佳时机&lt;/a&gt;，本题的主要区别在于：考虑的不只是单次买卖股票的情形，可以对一只股票多次进行买卖，需要求解的是整体的最优化。&lt;/p&gt;
&lt;p&gt;要想实现最大的利润，那么本质上就是在序列中寻找单调区间，将序列中的全部单调增区间的区间长度相加，就是最大的利润值。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; prices)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n=prices.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; start=prices[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],last=start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(prices[i]&amp;gt;=last)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                last=prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res+=last-start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                start=prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                last=start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res+=last-start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更加高效的贪心实现：在本题中，交易的次数是不存在限制的，因此完全可以采取如下策略。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;i-1&lt;/code&gt; 只要 &lt;code&gt;prices[i]&amp;gt;prices[i-1]&lt;/code&gt; 那么就在 &lt;code&gt;i-1&lt;/code&gt; 买入，在 &lt;code&gt;i&lt;/code&gt; 天卖出，也就是赚取全部能够赚取的利润。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; prices)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n=prices.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res+=&lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,prices[i]-prices[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-122-买卖股票的最佳时机II"><a href="#LeetCode-122-买卖股票的最佳时机II" class="headerlink" title="LeetCode 122 买卖股票的最佳时机II"></a>LeetCode 122 买卖股票的最佳时机II</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机II</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润。</p><p>示例：</p><blockquote><p>输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。<br>     总利润为 4 + 3 = 7 。</p></blockquote><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>相较于<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a>，本题的主要区别在于：考虑的不只是单次买卖股票的情形，可以对一只股票多次进行买卖，需要求解的是整体的最优化。</p><p>要想实现最大的利润，那么本质上就是在序列中寻找单调区间，将序列中的全部单调增区间的区间长度相加，就是最大的利润值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start=prices[<span class="number">0</span>],last=start;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;=last)&#123;</span><br><span class="line">                last=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=last-start;</span><br><span class="line">                start=prices[i];</span><br><span class="line">                last=start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=last-start;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更加高效的贪心实现：在本题中，交易的次数是不存在限制的，因此完全可以采取如下策略。</p><p>对于 <code>i</code> 和 <code>i-1</code> 只要 <code>prices[i]&gt;prices[i-1]</code> 那么就在 <code>i-1</code> 买入，在 <code>i</code> 天卖出，也就是赚取全部能够赚取的利润。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res+=<span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，寻找单调递增区间的操作基于暴力法也是能够实现的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处使用动态规划进行求解存在两个要点：首先是动态规划数组的定义，其次是动态规划数组的定义（本质上还是如何对问题进行划分）</p><ol><li><p>动态规划数组的定义：定义一个二维的动态规划数组 <code>dp[n][2]</code> ，其中 <code>dp[i][0]</code> 表示在第 <code>i</code> 持有股票所拥有的现金， <code>dp[i][1]</code> 表示在第 <code>i</code> <strong>天不持有股票所能获得最多的现金</strong>。关于现金的含义：在初始状态现金为0，那么在某天买入后现金是 <code>-prices[i]</code> ，只有在股票卖出后当前持有的现金才会发生改变。</p></li><li><p>动态规划数组的推导：</p></li></ol><p>对于 <code>dp[i][0]</code> 的推导：本质上还是针对于前一天的情形进行推导</p><ul><li>前一天持有的情形，在第 <code>i</code> 天无需对股票进行操作 <code>dp[i][0]=dp[i-1][0]</code> </li><li>前一天不持有的情形， <code>dp[i][0]=dp[i-1][1]-prices[i]</code> 也就是在第 <code>i</code> 天进行了股票的买入</li></ul><p>对于 <code>dp[i][1]</code> 的推导：在前一天持有或不持有两种情形</p><ul><li>前一天持有的情形，在第 <code>i</code> 天对股票进行卖出操作 <code>dp[i][1]=dp[i-1][0]+prices[i]</code> </li><li>前一天不持有的情形， <code>dp[i][1]=dp[i-1][1]</code> 也就是在第 <code>i</code> 天不对股票进行操作</li></ul><ol><li><p>动态规划数组的初始化：对于第0天的情形，不持有股票现金为0，持有股票现金为 <code>-prices[0]</code> ，那么 <code>dp[0][0]=-prices[0],dp[0][1]=0</code></p></li><li><p>动态规划数组的遍历顺序：从前向后遍历</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为滚动数组实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]-=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>]+prices[i],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/4faebc0f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-121-买卖股票的最佳时机</title>
      <link>http://marksblog.cn/posts/3f336a0e/</link>
      <guid>http://marksblog.cn/posts/3f336a0e/</guid>
      <pubDate>Mon, 05 Jun 2023 15:25:56 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 &lt;code&gt;i&lt;/code&gt; 天买入，能够获得最大利润使用 &lt;code&gt;dp[i]&lt;/code&gt; 表示，那么第 &lt;code&gt;i+1&lt;/code&gt; 天买入能够获得的最大利润使用 &lt;code&gt;dp[i+1]&lt;/code&gt; 表示，那么 &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt; ，那么使用动态规划进行求解的过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 天买入能够获得的最大利润&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导： &lt;code&gt;dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 &lt;code&gt;dp[n+1]=0&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在计算 &lt;code&gt;dp[n]&lt;/code&gt; 时需要使用 &lt;code&gt;dp[n+1]&lt;/code&gt; 的信息，因此此处需要使用从后向前遍历的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;code&gt;vector&amp;lt;int&amp;gt; prices=&amp;#123;7,1,5,3,6,4&amp;#125;;&lt;/code&gt; 动态规划数组的输出为： &lt;code&gt;dp=[0,0,3,1,5,0]&lt;/code&gt; 验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121 买卖股票的最佳时机"></a>LeetCode 121 买卖股票的最佳时机</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>示例</p><blockquote><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题的重点在于递推关系的确定，此处只考虑买入时间，不考虑卖出时间（本质上卖出时间就是最大利润的那一天）：第 <code>i</code> 天买入，能够获得最大利润使用 <code>dp[i]</code> 表示，那么第 <code>i+1</code> 天买入能够获得的最大利润使用 <code>dp[i+1]</code> 表示，那么 <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code> ，那么使用动态规划进行求解的过程为：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示第 <code>n</code> 天买入能够获得的最大利润</p></li><li><p>动态规划数组的推导： <code>dp[i]=max(dp[i+1]+(prices[i]-prices[i-1]),0)</code></p></li><li><p>动态规划数组的初始化：对于最后一天买入的股票，必然不能盈利那么 <code>dp[n+1]=0</code> </p></li><li><p>动态规划数组的遍历顺序：在计算 <code>dp[n]</code> 时需要使用 <code>dp[n+1]</code> 的信息，因此此处需要使用从后向前遍历的方式。</p></li><li><p>对于 <code>vector&lt;int&gt; prices=&#123;7,1,5,3,6,4&#125;;</code> 动态规划数组的输出为： <code>dp=[0,0,3,1,5,0]</code> 验证正确</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>]+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处仅仅使用到了前一天的状态，那么可以基于滚动数组实现，从而减少空间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            n1=<span class="built_in">max</span>(n0+(prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">            res=<span class="built_in">max</span>(res,n1);</span><br><span class="line">            n0=n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>本质上就是在一个数组中，寻找两个点之间的最大间距，使用一个双for循环即可完成穷举。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,prices[j]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式将会超出时间限制。</p><h2 id="贪心实现"><a href="#贪心实现" class="headerlink" title="贪心实现"></a>贪心实现</h2><p>最简单的思想就是，在左边找到一个最小值，在右边找到一个最大值，做减法即可得到需要求解的值。</p><p>在左边寻找最小值的过程，本质上就是在从左向右遍历的过程中记录最小值，让当前值始终与记录的最小值做减法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minp=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minp=<span class="built_in">min</span>(minp,prices[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,prices[i]-minp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/">股票买卖</category>
      
      
      <comments>http://marksblog.cn/posts/3f336a0e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-337-打家劫舍III</title>
      <link>http://marksblog.cn/posts/1aa3096f/</link>
      <guid>http://marksblog.cn/posts/1aa3096f/</guid>
      <pubDate>Mon, 05 Jun 2023 14:31:28 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;深度优先&quot;&gt;&lt;a href=&quot;#深度优先&quot; class=&quot;headerlink&quot; title=&quot;深度优先&quot;&gt;&lt;/a&gt;深度优先&lt;/h2&gt;&lt;p&gt;改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。&lt;/p&gt;
&lt;p&gt;暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;robTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 计算对于以root为根节点能够抢到的最大的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 当前节点非空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val1=root-&amp;gt;val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;left) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;right) val1+=(&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right-&amp;gt;right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val2=&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;left)+&lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(val1,val2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;robTree&lt;/span&gt;(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。&lt;/p&gt;
&lt;p&gt;记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 &lt;code&gt;robTree(root-&amp;gt;left)&lt;/code&gt; 的时候就重复计算了 &lt;code&gt;(robTree(root-&amp;gt;left-&amp;gt;left)+robTree(root-&amp;gt;left-&amp;gt;right))&lt;/code&gt; ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-337-打家劫舍III"><a href="#LeetCode-337-打家劫舍III" class="headerlink" title="LeetCode 337 打家劫舍III"></a>LeetCode 337 打家劫舍III</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍III</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例：</p><p><img src="打家劫舍III.png" alt="打家劫舍III"></p><blockquote><p>  输入: root = [3,2,3,null,3,null,1]<br>    输出: 7<br>    解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p></blockquote><h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>改变了相邻节点的定义：此处是在一棵二叉树中进行节点的选取，使得节点的和值最大，那么从父节点开始遍历，选取了父节点就不能选取子节点。</p><p>暴力搜索实现：遍历每一种合法的选取情形，判断能够选取到的最大值。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123; <span class="comment">// 计算对于以root为根节点能够抢到的最大的值</span></span><br><span class="line">        <span class="keyword">if</span>(root)&#123; <span class="comment">// 当前节点非空</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="type">int</span> val1=root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) val1+=(<span class="built_in">robTree</span>(root-&gt;left-&gt;left)+<span class="built_in">robTree</span>(root-&gt;left-&gt;right));</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) val1+=(<span class="built_in">robTree</span>(root-&gt;right-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right-&gt;right));</span><br><span class="line">            <span class="type">int</span> val2=<span class="built_in">robTree</span>(root-&gt;left)+<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(val1,val2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">robTree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的实现方式，本质上是在进行穷举，不断尝试选取方案，类似于是回溯的方法实现，在LeetCode的测试用例中将会超出时间限制。</p><p>记忆化搜索：在上述的计算过程中存在较多的重复计算。比如在计算 <code>robTree(root-&gt;left)</code> 的时候就重复计算了 <code>(robTree(root-&gt;left-&gt;left)+robTree(root-&gt;left-&gt;right))</code> ，使用一个map记录计算的过程，从而减少计算。此处在基于记忆化搜索时，有一个非常需要注意的点：使用一个Map进行记录，那么对于正在寻找最大值的当前节点，在开始遍历前，尝试访问map中的数据，若是访问成功，那么本次求解直接结束（在非空和非叶子节点的情形下），若是访问失败，那么按照正常的遍历方式去进行DFS，在本次访问返回前将相应的数值存储在map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode* , <span class="type">int</span>&gt; umap; <span class="comment">// 记录计算过的结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (umap[root]) <span class="keyword">return</span> umap[root]; <span class="comment">// 如果umap里已经有记录则直接返回</span></span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="type">int</span> val1 = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) val1 += <span class="built_in">rob</span>(root-&gt;left-&gt;left) + <span class="built_in">rob</span>(root-&gt;left-&gt;right); <span class="comment">// 跳过root-&gt;left</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) val1 += <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right); <span class="comment">// 跳过root-&gt;right</span></span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right); <span class="comment">// 考虑root的左右孩子</span></span><br><span class="line">        umap[root] = <span class="built_in">max</span>(val1, val2); <span class="comment">// umap记录一下结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处的动态规划实现，基本上和记忆化搜索类似。也是在递归的基础上实现。进行动态规划的基本思路依旧是：对于以 <code>root</code> 为根的子树，能够选取到的最大的节点数值总和为，max(选取当前节点+两棵子树后代的最大值，不选当前节点两棵子树的最大值之和) 。</p><p>此处需要基于动态规划实现，并且要避免重复的计算操作，那么使用一个递归函数，返回一个长度为2的数组，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p><ol><li><p>动态规划数组的定义：对于递归函数 <code>robTree(TreeNode* root)</code>，返回 <code>vector&lt;int&gt; dp(2)</code> ，分别记录：选取根节点能够获取的最大值，不选取根节点能够获取到的最大值。</p></li><li><p>动态规划数组的推导：在当前的递归函数层中，需要计算的有两个值，其中 <code>dp[0]</code> 表示的是选取根节点能够获取到的最大值，那么左右孩子节点是一定不能够选取的 <code>dp[0]=root-&gt;val+robTree(root-&gt;left)[1]+robTree(root-&gt;right)[1]</code> ，对于<code>dp[1]</code> 表示的是不选取根节点能够获取到的最大值，此时左右孩子节点是可选可不选的，那么具体能否进行选取，取决那种方式能够获取到更大的值 <code>dp[1]=max(robTree(root-&gt;left)[0],robTree(root-&gt;left)[1])+max(robTree(root-&gt;right)[0],robTree(root-&gt;right)[1])</code></p></li><li><p>动态规划数组的初始化：对于空节点 <code>robTree(nullptr)=&#123;0,0&#125;</code></p></li><li><p>动态规划数组的遍历顺序：本质上就是DFS，并且对于根节点而言是后序遍历</p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            res[<span class="number">0</span>]=root-&gt;val+val1[<span class="number">1</span>]+val2[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>]=<span class="built_in">max</span>(val1[<span class="number">0</span>],val1[<span class="number">1</span>])+<span class="built_in">max</span>(val2[<span class="number">0</span>],val2[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在动态规划的过程中，采取的是后序遍历的方式，上层节点的值是在底层节点的值完成计算后，才得到的，并且使用一个vector数组同时记录了选取根节点和不选取根节点的最优解。但是由于在递归函数的返回值中使用的是vector数组，vector数组在创建时将会预分配较大的内存空间，导致程序的开销较大，此处改用 <code>pair</code> ，将会使得LeetCode上的运行时间和内存空间大大降低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val1=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; val2=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line">            res.first=root-&gt;val+val1.second+val2.second;</span><br><span class="line">            res.second=<span class="built_in">max</span>(val1.first,val1.second)+<span class="built_in">max</span>(val2.first,val2.second);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res=<span class="built_in">robTree</span>(root);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(res.first,res.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/1aa3096f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-213-打家劫舍II</title>
      <link>http://marksblog.cn/posts/null/</link>
      <guid>http://marksblog.cn/posts/null/</guid>
      <pubDate>Sat, 03 Jun 2023 12:13:54 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;本题相较于&lt;a href=&quot;https://leetcode.cn/problems/house-robber/&quot;&gt;198.打家劫舍&lt;/a&gt;的主要区别在于，首尾的元素也成了相邻元素，导致元素成为了一个环，因此不能采取前面的方式计算。&lt;/p&gt;
&lt;p&gt;此处可以将问题进行转化：此处的首尾元素只有一个可以被选取，那么将问题划分为两部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不选取首元素，那么此时尾元素就可以选取，问题转化为在后n-1个元素不相邻选取最大值，求得res1&lt;/li&gt;
&lt;li&gt;不选取尾元素，那么此时首元素就可以选取，问题转化为在前n-1个元素不相邻选取最大值，求得res2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在得到res1和res2后，只需要选取其中较大的即可，在此基础上，使用动态规划求解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[i]&lt;/code&gt; 表示在 &lt;code&gt;0-i&lt;/code&gt; 的元素中选取，能够得到的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：不选取当前元素 &lt;code&gt;i&lt;/code&gt; 那么 &lt;code&gt;i-1&lt;/code&gt; 是可以被选取(不代表一定选取)，选取当前元素 &lt;code&gt;i&lt;/code&gt; 那么 &lt;code&gt;i-1&lt;/code&gt; 不可选取，从 &lt;code&gt;dp[i-2]&lt;/code&gt; 计算 &lt;code&gt;dp[i]=max(dp[i-1],dp[i-2]+nums[i])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于情况2 &lt;code&gt;dp[0]=nums[0],dp[1]=max(nums[0],nums[1])&lt;/code&gt; ，对于情况1 &lt;code&gt;dp[0]=nums[1],dp[1]=max(nums[1],nums[2])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：需要使用前面的两个元素，从前向后遍历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=[2,3,2]&lt;/code&gt; 输出结果为 &lt;code&gt;3&lt;/code&gt; ，验证正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-213-打家劫舍II"><a href="#LeetCode-213-打家劫舍II" class="headerlink" title="LeetCode 213 打家劫舍II"></a>LeetCode 213 打家劫舍II</h1><p><a href="https://leetcode.cn/problems/house-robber-ii/">213.打家劫舍II</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例：</p><blockquote><p>  输入：nums = [2,3,2]<br>    输出：3<br>    解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本题相较于<a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a>的主要区别在于，首尾的元素也成了相邻元素，导致元素成为了一个环，因此不能采取前面的方式计算。</p><p>此处可以将问题进行转化：此处的首尾元素只有一个可以被选取，那么将问题划分为两部分。</p><ol><li>不选取首元素，那么此时尾元素就可以选取，问题转化为在后n-1个元素不相邻选取最大值，求得res1</li><li>不选取尾元素，那么此时首元素就可以选取，问题转化为在前n-1个元素不相邻选取最大值，求得res2</li></ol><p>在得到res1和res2后，只需要选取其中较大的即可，在此基础上，使用动态规划求解：</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[i]</code> 表示在 <code>0-i</code> 的元素中选取，能够得到的最大值</p></li><li><p>动态规划数组的推导：不选取当前元素 <code>i</code> 那么 <code>i-1</code> 是可以被选取(不代表一定选取)，选取当前元素 <code>i</code> 那么 <code>i-1</code> 不可选取，从 <code>dp[i-2]</code> 计算 <code>dp[i]=max(dp[i-1],dp[i-2]+nums[i])</code></p></li><li><p>动态规划数组的初始化：对于情况2 <code>dp[0]=nums[0],dp[1]=max(nums[0],nums[1])</code> ，对于情况1 <code>dp[0]=nums[1],dp[1]=max(nums[1],nums[2])</code></p></li><li><p>动态规划数组的遍历顺序：需要使用前面的两个元素，从前向后遍历</p></li><li><p>举例验证：对于 <code>nums=[2,3,2]</code> 输出结果为 <code>3</code> ，验证正确</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> n0=nums[<span class="number">0</span>],n1=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res1=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]),res2=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res1=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res1;</span><br><span class="line">        &#125;</span><br><span class="line">        n0=nums[<span class="number">1</span>],n1=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res2=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将求解非环状序列的操作封装为函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n0=nums[start],n1=<span class="built_in">max</span>(nums[start],nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res=n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">2</span>;i&lt;end;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(n1,n0+nums[i]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> res1=<span class="built_in">robRange</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> res2=<span class="built_in">robRange</span>(nums,<span class="number">1</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/null/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-198-打家劫舍</title>
      <link>http://marksblog.cn/posts/9b6273f5/</link>
      <guid>http://marksblog.cn/posts/9b6273f5/</guid>
      <pubDate>Sat, 03 Jun 2023 11:33:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[nums.size()+1]&lt;/code&gt; 表示在 &lt;code&gt;nums.size()&lt;/code&gt; 个物品中进行选取能够得到的最大的物品价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在 &lt;code&gt;j&lt;/code&gt; 个物品中选取，可以选取第 &lt;code&gt;j&lt;/code&gt; 个物品也可以不进行选取，那么 &lt;code&gt;dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 不存在可选元素， &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于 &lt;code&gt;dp[1]&lt;/code&gt; 只能选取第一个元素 &lt;code&gt;dp[1]=nums[0]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;nums=[1,2,3,1]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;dp={0,1,0,0,0}&lt;br&gt;dp={0,1,2,0,0}&lt;br&gt;dp={0,1,2,4,0}&lt;br&gt;dp={0,1,2,4,4}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode 198 打家劫舍"></a>LeetCode 198 打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><blockquote><p>  输入：[1,2,3,1]<br>    输出：4<br>    解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>        偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此处是一个非常明显的动态规划问题，在物品的选取上，主要的限制在于不能选取两个相邻的物品，在此条件下实现物品价值的最大化。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[nums.size()+1]</code> 表示在 <code>nums.size()</code> 个物品中进行选取能够得到的最大的物品价值。</p></li><li><p>动态规划数组的推导：在 <code>j</code> 个物品中选取，可以选取第 <code>j</code> 个物品也可以不进行选取，那么 <code>dp[j]=max(dp[j-1],dp[j-2]+nums[j-1])</code></p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 不存在可选元素， <code>dp[0]=0</code> ，对于 <code>dp[1]</code> 只能选取第一个元素 <code>dp[1]=nums[0]</code> </p></li><li><p>动态规划数组的遍历顺序：在递推的过程中使用到的前面的数据，因此从前向后遍历。</p></li><li><p>举例验证：对于 <code>nums=[1,2,3,1]</code> </p></li></ol><blockquote><p>dp={0,1,0,0,0}<br>dp={0,1,2,0,0}<br>dp={0,1,2,4,0}<br>dp={0,1,2,4,4}</p></blockquote><p>验证正确。</p><p>此处在进行计算时，实际上只使用到了前两个元素的值，那么只需要常数的元素空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> n0=<span class="number">0</span>,n1=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(n1,n0+nums[i<span class="number">-1</span>]);</span><br><span class="line">            n0=n1;</span><br><span class="line">            n1=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</category>
      
      
      <comments>http://marksblog.cn/posts/9b6273f5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>完全背包问题总结</title>
      <link>http://marksblog.cn/posts/97265db6/</link>
      <guid>http://marksblog.cn/posts/97265db6/</guid>
      <pubDate>Fri, 02 Jun 2023 12:30:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;完全背包问题总结&quot;&gt;&lt;a href=&quot;#完全背包问题总结&quot; class=&quot;headerlink&quot; title=&quot;完全背包问题总结&quot;&gt;&lt;/a&gt;完全背包问题总结&lt;/h1&gt;&lt;p&gt;首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 &lt;code&gt;W&lt;/code&gt; 的背包。第 &lt;code&gt;i&lt;/code&gt; 件物品的重量是 &lt;code&gt;weight[i]&lt;/code&gt; ，得到的价值是 &lt;code&gt;value[i]&lt;/code&gt; 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。&lt;/p&gt;
&lt;p&gt;相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 &lt;code&gt;n&lt;/code&gt; 个物品可供选择（即从所有的物品中做任意的选择）。&lt;/p&gt;
&lt;p&gt;完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 &lt;code&gt;i&lt;/code&gt; 次迭代时，0/1背包只能使用一次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 &lt;code&gt;weight[i]&lt;/code&gt; ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="完全背包问题总结"><a href="#完全背包问题总结" class="headerlink" title="完全背包问题总结"></a>完全背包问题总结</h1><p>首先，需要清楚的是对于完全背包问题的定义：有N件物品和一个最多能背重量为 <code>W</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code> ，得到的价值是 <code>value[i]</code> 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p><p>相较于0/1背包问题，完全背包问题最大的不同之处在物品的个数是无限。那么在进行选择时，就是每一次向背包中添加物品时，都有 <code>n</code> 个物品可供选择（即从所有的物品中做任意的选择）。</p><p>完全背包问题的实现只需要在0/1背包的基础上稍作改动即可，依旧是采取滚动数组实现。</p><ol><li><p>对于先便利物品，再遍历背包的情形：那么完全背包相较于0/1背包的不同之处，在第 <code>i</code> 次迭代时，0/1背包只能使用一次物品 <code>weight[i]</code> ，因此采取从后向前的方式遍历，为了防止重复选择，但是完全背包可以使用任意次物品 <code>weight[i]</code> ，所以需要实现重复的选取，因此采取从前向后的遍历方式即可。并且这种先遍历物品再遍历背包的方式，本质上是在求解组合问题，也就是对于物品的选取顺序是不敏感的，仅对物品的个数敏感。（因为先遍历物品，因此也就确定了选取的顺序）</p></li><li><p>先遍历背包，再遍历物品：也就是对于每一种情形下的背包容量，都从全部的物品中进行选择。在单纯的完全背包问题下，递推公式和结果是不会改变的。但是这样的遍历方式，本质上是在求解排列问题，也就是对于物品的选取顺序是敏感的，因为先遍历的是背包容量，在背包容量增大的过程中，最后一次选取的物品不同将会是不同的情形。</p></li></ol><h2 id="LeetCode-377-组合总和Ⅳ"><a href="#LeetCode-377-组合总和Ⅳ" class="headerlink" title="LeetCode 377 组合总和Ⅳ"></a>LeetCode 377 组合总和Ⅳ</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和 Ⅳ</a></p><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>本题求解的并不是组合问题，是一个排序问题，在题目示例中将 <code>1,2,1</code> 和 <code>1,1,2</code> 视为两种不同的组合，也就是对于元素的选取顺序是敏感的。那么应该先遍历背包再遍历物品，并且此处求解的是恰好装满的情形，相应的递推公式为 <code>dp[j]+=dp[j-nums[i]]</code></p><h2 id="LeetCode-518-零钱兑换II"><a href="#LeetCode-518-零钱兑换II" class="headerlink" title="LeetCode 518 零钱兑换II"></a>LeetCode 518 零钱兑换II</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">518.零钱兑换II</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>根据题中的示例，本题求解的是一个组合问题。</p><p>并且此处的背包问题是一个恰好装满的情形，那么对于组合问题基本思路就是先遍历物品再遍历背包，那么递推公式为： <code>dp[j]+=dp[j-coins[i]]</code> ，在进行初始化是一定要将 <code>dp[0]=1</code> </p><h2 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode 322 零钱兑换"></a>LeetCode 322 零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>此处的最优化问题为：求解能够恰好装满背包的最少硬币数量，那么对于组合和排列都是相同的，两种遍历顺序都是可以的。基本的递推公式为：<code>dp[j]=min(dp[j],dp[j-coins[i]]+1)</code> ，要让上述递推公式成立，需要在数组的初始化时进行特殊处理，对于 <code>dp[0]</code> 只需要0个硬币即可装满。那么对于其他的值明显都装不满，因此初始为 <code>INT_MAX</code> ，并且每次判断 <code>dp[j-coins[i]]!=INT_MAX</code></p><h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>此处和上述问题是非常类似的，也是在求解将背包恰好装满的最少的元素数量。但是此处的元素要求是完全平方数，因此在遍历物品的同时去生成相应的完全平方数即可。对于 <code>dp[0]</code> 依旧是初始化为0。其他元素全部初始化为 <code>INT_MAX</code> 。对应的递推公式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 要求 <code>dp[j-nums[i]]!=INT_MAX</code></p><h2 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>此处需要注意的是：本题是一个排列问题，一定要先遍历背包，再遍历物品，也就是对于任意的背包大小都要能够使用全部的物品去进行填充，否则对于 <code>applepenapple</code> 这样的情形，在仅使用 <code>apple</code> 时，不能将后续的也标记为装满。那么在使用 <code>pen</code> 去填充时，无法使用 <code>apple</code> 将后续填满。</p>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/97265db6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-139-单词拆分</title>
      <link>http://marksblog.cn/posts/4a1c4ee7/</link>
      <guid>http://marksblog.cn/posts/4a1c4ee7/</guid>
      <pubDate>Thu, 01 Jun 2023 00:58:59 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。&lt;/p&gt;
&lt;p&gt;此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）&lt;/p&gt;
&lt;p&gt;考虑这样一种情况： &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 那么先遍历物品，再遍历背包，初始时只能使用 &lt;code&gt;apple&lt;/code&gt; 那么只能将第一个 &lt;code&gt;apple&lt;/code&gt; 恰好装满，在第二次迭代中，是只考虑增加 &lt;code&gt;pen&lt;/code&gt; 的情形，但实际上还需要使用 &lt;code&gt;apple&lt;/code&gt; 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[s.size()+1]&lt;/code&gt; 表示长度为 &lt;code&gt;s.size()&lt;/code&gt; 的字符串能否恰好装满&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;j&lt;/code&gt; 次迭代中，判断字符从 &lt;code&gt;0-j-1&lt;/code&gt; 位置的字符串 &lt;code&gt;s&lt;/code&gt; 能否恰好装满，对于每一个物品 &lt;code&gt;wordDict[i]&lt;/code&gt; 都需要尝试从 &lt;code&gt;j-1&lt;/code&gt; 处向前装入试试，所以有：其中 &lt;code&gt;match&lt;/code&gt; 是字符串匹配操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(j&amp;gt;=wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dp[j]=dp[j]||(dp[j-wordDict[i].&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()]&amp;amp;&amp;amp;&lt;span class=&quot;built_in&quot;&gt;match&lt;/span&gt;(s,j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,wordDict[i]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于&lt;code&gt;dp[0]&lt;/code&gt; 一定是能够恰好装满的，所以 &lt;code&gt;dp[0]=true&lt;/code&gt; 其他全部初始化为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：对于 &lt;code&gt;s=&amp;quot;applepenapple&amp;quot; wordDict=[&amp;quot;apple&amp;quot;,&amp;quot;pen&amp;quot;]&lt;/code&gt; 动态规划数组的推导过程为：验证成立&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,0,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,0,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,0,&lt;br&gt;    1,0,0,0,0,1,0,0,1,0,0,0,0,1,&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139 单词拆分"></a>LeetCode 139 单词拆分</h1><p><a href="https://leetcode.cn/problems/word-break/">139.单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例：</p><blockquote><p>  输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>    输出: true<br>    解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p></blockquote><ul><li>1 &lt;= <code>s.length</code> &lt;= 300</li><li>1 &lt;= <code>wordDict.length</code> &lt;= 1000</li><li>1 &lt;= <code>wordDict[i].length</code> &lt;= 20</li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 互不相同</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题：此处的背包问题并不是求解最优化，而是判断能否将背包装满。但是此处的背包不同于之前的背包，背包中装入的必须是特定的元素。</p><p>此处需要判断的是能否恰好装满，若是先遍历物品，再遍历背包，那么实际上限制了物品元素的使用。（本质上是一个排列问题，元素在背包中有序）</p><p>考虑这样一种情况： <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 那么先遍历物品，再遍历背包，初始时只能使用 <code>apple</code> 那么只能将第一个 <code>apple</code> 恰好装满，在第二次迭代中，是只考虑增加 <code>pen</code> 的情形，但实际上还需要使用 <code>apple</code> 对尾部进行装填，也就是每次向背包中装入时，需要使用到全部的物品，所以应该先遍历背包再遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[s.size()+1]</code> 表示长度为 <code>s.size()</code> 的字符串能否恰好装满</p></li><li><p>动态规划数组的推导：在第 <code>j</code> 次迭代中，判断字符从 <code>0-j-1</code> 位置的字符串 <code>s</code> 能否恰好装满，对于每一个物品 <code>wordDict[i]</code> 都需要尝试从 <code>j-1</code> 处向前装入试试，所以有：其中 <code>match</code> 是字符串匹配操作。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态规划数组的初始化：对于<code>dp[0]</code> 一定是能够恰好装满的，所以 <code>dp[0]=true</code> 其他全部初始化为 <code>false</code></p></li><li><p>动态规划数组的遍历顺序：此处采取先遍历背包，再遍历物品的方式，物品和背包都采取从前向后遍历的方式</p></li><li><p>举例验证：对于 <code>s=&quot;applepenapple&quot; wordDict=[&quot;apple&quot;,&quot;pen&quot;]</code> 动态规划数组的推导过程为：验证成立</p></li></ol><blockquote><p>  1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,0,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,0,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,0,<br>    1,0,0,0,0,1,0,0,1,0,0,0,0,1,</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string&amp; s,<span class="type">int</span> j,string&amp; word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i]!=s[j-word.<span class="built_in">size</span>()+<span class="number">1</span>+i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordDict.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=wordDict[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    dp[j]=dp[j]||(dp[j-wordDict[i].<span class="built_in">size</span>()]&amp;&amp;<span class="built_in">match</span>(s,j<span class="number">-1</span>,wordDict[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      <category domain="http://marksblog.cn/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">完全背包</category>
      
      
      <comments>http://marksblog.cn/posts/4a1c4ee7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode-279-完全平方数</title>
      <link>http://marksblog.cn/posts/null/</link>
      <guid>http://marksblog.cn/posts/null/</guid>
      <pubDate>Tue, 30 May 2023 12:20:19 GMT</pubDate>
      
      <description>&lt;p&gt;将问题转化为完全背包问题，那么此处背包的容量就是 &lt;code&gt;n&lt;/code&gt; ，并没有给定相应的物品，但是要将背包 &lt;code&gt;n&lt;/code&gt; 装满，那么使用的物品就应该是 &lt;code&gt;1-n&lt;/code&gt; 中的全部完全平方数，首先创建物品数组。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; nums;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i*i&amp;lt;=n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nums.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(i*i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么此处的物品数组就是 &lt;code&gt;nums&lt;/code&gt; ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和&lt;a href=&quot;https://leetcode.cn/problems/coin-change/&quot;&gt;322.零钱兑换&lt;/a&gt;完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的定义：定义数组 &lt;code&gt;dp[n+1]&lt;/code&gt; 表示总和为 &lt;code&gt;n&lt;/code&gt; 的最少的完全平方数的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的推导：在第 &lt;code&gt;i&lt;/code&gt; 次迭代中，考虑元素 &lt;code&gt;nums[i]&lt;/code&gt; ，尝试使用 &lt;code&gt;nums[i]&lt;/code&gt; 来减少数量 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; （此处需要判断 &lt;code&gt;dp[j-nums[i]]!=INT_MAX&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的初始化：对于 &lt;code&gt;dp[0]&lt;/code&gt; 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 &lt;code&gt;dp[0]=0&lt;/code&gt; ，对于其他元素，由于递推方式为 &lt;code&gt;dp[j]=min(dp[j],dp[j-nums[i]]+1)&lt;/code&gt; 那么对于初始不能恰好装满的容量，都初始化为 &lt;code&gt;INT_MAX&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例验证：&lt;code&gt;n=13&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}&lt;br&gt;    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode 279 完全平方数"></a>LeetCode 279 完全平方数</h1><p><a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例：</p><blockquote><p>  输入：n = 13<br>    输出：2<br>    解释：13 = 4 + 9</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>将问题转化为完全背包问题，那么此处背包的容量就是 <code>n</code> ，并没有给定相应的物品，但是要将背包 <code>n</code> 装满，那么使用的物品就应该是 <code>1-n</code> 中的全部完全平方数，首先创建物品数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此处的物品数组就是 <code>nums</code> ，在物品数组中选取物品将背包装满，要求使用的物品数量能少。那么此处的处理方式就是和<a href="https://leetcode.cn/problems/coin-change/">322.零钱兑换</a>完全相同。此处求解的是最少的完全平方数的个数，不存在组合和排列的问题，因此既可以先遍历背包也可以先遍历物品。</p><ol><li><p>动态规划数组的定义：定义数组 <code>dp[n+1]</code> 表示总和为 <code>n</code> 的最少的完全平方数的数量</p></li><li><p>动态规划数组的推导：在第 <code>i</code> 次迭代中，考虑元素 <code>nums[i]</code> ，尝试使用 <code>nums[i]</code> 来减少数量 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> （此处需要判断 <code>dp[j-nums[i]]!=INT_MAX</code>）</p></li><li><p>动态规划数组的初始化：对于 <code>dp[0]</code> 实际是不符合问题的定义，为了满足后续的计算，将其初始化为 <code>dp[0]=0</code> ，对于其他元素，由于递推方式为 <code>dp[j]=min(dp[j],dp[j-nums[i]]+1)</code> 那么对于初始不能恰好装满的容量，都初始化为 <code>INT_MAX</code> 。</p></li><li><p>动态规划数组的遍历顺序：此处先遍历物品再遍历背包，并且都采用从前向后的遍历方式。</p></li><li><p>举例验证：<code>n=13</code> </p></li></ol><blockquote><p>  dp={0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4}<br>    dp={0, 1, 2, 3, 1, 2, 3, 4, 2, 1, 2, 3, 3, 2}</p></blockquote><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums[i];j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-nums[i]]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-nums[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处的空间复杂度可优化，对于物品数组是可以不存储的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-i*i]!=INT_MAX)&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://marksblog.cn/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://marksblog.cn/tags/c/">c++</category>
      
      <category domain="http://marksblog.cn/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://marksblog.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</category>
      
      
      <comments>http://marksblog.cn/posts/null/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
